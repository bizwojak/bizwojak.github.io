<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style>
.AlignLeft { text-align: left; }
.AlignCenter { text-align: center; }
.AlignRight { text-align: right; }
body { font-family: sans-serif; font-size: 11pt; }
img.AutoScale { max-width: 100%; max-height: 100%; }
td { vertical-align: top; padding-left: 4px; padding-right: 4px; }

tr.SectionGap td { font-size: 4px; border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionBegin td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionMiddle td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SubsectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
tr.SubsectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
table.fc { border-top: 1px solid Black; border-left: 1px solid Black; width: 100%; font-family: monospace; font-size: 10pt; }
td.TextItemInsigMod { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigOrphan { color: #000000; background-color: #FAEEFF; }
td.TextItemNum { color: #696969; background-color: #F0F0F0; }
td.TextItemSame { color: #000000; background-color: #FFFFFF; }
td.TextItemSigMod { color: #000000; background-color: #FFE3E3; }
td.TextItemSigOrphan { color: #000000; background-color: #F1E3FF; }
.TextSegInsigDiff { color: #0000FF; }
.TextSegReplacedDiff { color: #0000FF; font-style: italic; }
.TextSegSigDiff { color: #FF0000; }
td.TextItemInsigAdd { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigDel { color: #000000; background-color: #EEEEFF; text-decoration: line-through; }
td.TextItemSigAdd { color: #000000; background-color: #FFE3E3; }
td.TextItemSigDel { color: #000000; background-color: #FFE3E3; text-decoration: line-through; }
.TextSegElementComment { color: #786A41; }
</style>
<title>dcrd-1.1.0 <--> hxd-rc1.0 Comparison</title>
</head>
<body>
dcrd-1.1.0 <--> hxd-rc1.0 Comparison<br/>
Produced: 10/3/2018 11:00:21 PM<br/>
&nbsp; &nbsp;
<br/>
Mode:&nbsp; All, Ignoring Unimportant &nbsp;
<br/>
Left file: dcrd-1.1.0\dcrec\secp256k1\signature.go &nbsp;
<br/>
Right file: hxd-rc1.0\dcrec\secp256k1\signature.go &nbsp;
<br/>
<table class="fc" cellspacing="0" cellpadding="0">
<tr class="SectionBegin">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2013-2014 The btcsuite developers</span></td>
<td class="AlignCenter">=</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2013-2014 The btcsuite developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2015-2016 The Decred developers</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2015-2016 The Decred developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">package secp256k1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">package secp256k1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">import (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">import (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;bytes&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;bytes&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/ecdsa&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/ecdsa&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/elliptic&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/elliptic&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/hmac&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/hmac&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/sha256&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;crypto/sha256&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;errors&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;errors&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;fmt&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;fmt&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;hash&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;hash&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;math/big&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;math/big&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Errors returned by canonicalPadding.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Errors returned by canonicalPadding.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">var (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">var (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errNegativeValue&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = errors.New(&quot;value may be interpreted as negative&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errNegativeValue&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = errors.New(&quot;value may be interpreted as negative&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errExcessivelyPaddedValue = errors.New(&quot;value is excessively padded&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errExcessivelyPaddedValue = errors.New(&quot;value is excessively padded&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Signature is a type representing an ecdsa signature.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Signature is a type representing an ecdsa signature.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">type Signature struct {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">type Signature struct {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; R *big.Int</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; R *big.Int</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; S *big.Int</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; S *big.Int</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">var (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">var (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Curve order and halforder, used to tame ECDSA malleability (see BIP-0062)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Curve order and halforder, used to tame ECDSA malleability (see BIP-0062)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; order&nbsp; &nbsp;&nbsp; = new(big.Int).Set(S256().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; order&nbsp; &nbsp;&nbsp; = new(big.Int).Set(S256().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; halforder = new(big.Int).Rsh(order, 1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; halforder = new(big.Int).Rsh(order, 1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Used in RFC6979 implementation when testing the nonce for correctness</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Used in RFC6979 implementation when testing the nonce for correctness</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; one = big.NewInt(1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; one = big.NewInt(1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// oneInitializer is used to fill a byte slice with byte 0x01.&nbsp; It is provided</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// oneInitializer is used to fill a byte slice with byte 0x01.&nbsp; It is provided</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// here to avoid the need to create it multiple times.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// here to avoid the need to create it multiple times.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; oneInitializer = []byte{0x01}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; oneInitializer = []byte{0x01}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NewSignature instantiates a new signature given some R,S values.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NewSignature instantiates a new signature given some R,S values.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func NewSignature(r, s *big.Int) *Signature {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func NewSignature(r, s *big.Int) *Signature {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;Signature{r, s}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;Signature{r, s}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Serialize returns the ECDSA signature in the more strict DER format.&nbsp; Note</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Serialize returns the ECDSA signature in the more strict DER format.&nbsp; Note</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// that the serialized bytes returned do not include the appended hash type</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// that the serialized bytes returned do not include the appended hash type</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// used in Decred signature scripts.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// used in Decred signature scripts.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// encoding/asn1 is broken so we hand roll this output:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// encoding/asn1 is broken so we hand roll this output:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// 0x30 &lt;length&gt; 0x02 &lt;length r&gt; r 0x02 &lt;length s&gt; s</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig *Signature) Serialize() []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig *Signature) Serialize() []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// low 'S' malleability breaker</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// low 'S' malleability breaker</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sigS := sig.S</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sigS := sig.S</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigS.Cmp(halforder) == 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigS.Cmp(halforder) == 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sigS = new(big.Int).Sub(order, sigS)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sigS = new(big.Int).Sub(order, sigS)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure the encoded bytes for the r and s values are canonical and</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure the encoded bytes for the r and s values are canonical and</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// thus suitable for DER encoding.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// thus suitable for DER encoding.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rb := canonicalizeInt(sig.R)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rb := canonicalizeInt(sig.R)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sb := canonicalizeInt(sigS)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sb := canonicalizeInt(sigS)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// total length of returned signature is 1 byte for each magic and</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// total length of returned signature is 1 byte for each magic and</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// length (6 total), plus lengths of r and s</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// length (6 total), plus lengths of r and s</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; length := 6 + len(rb) + len(sb)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; length := 6 + len(rb) + len(sb)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b := make([]byte, length)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b := make([]byte, length)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[0] = 0x30</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[0] = 0x30</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[1] = byte(length - 2)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[1] = byte(length - 2)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[2] = 0x02</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[2] = 0x02</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[3] = byte(len(rb))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[3] = byte(len(rb))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; offset := copy(b[4:], rb) + 4</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; offset := copy(b[4:], rb) + 4</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[offset] = 0x02</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[offset] = 0x02</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[offset+1] = byte(len(sb))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b[offset+1] = byte(len(sb))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(b[offset+2:], sb)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(b[offset+2:], sb)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return b</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return b</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Verify calls ecdsa.Verify to verify the signature of hash using the public</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Verify calls ecdsa.Verify to verify the signature of hash using the public</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// key.&nbsp; It returns true if the signature is valid, false otherwise.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// key.&nbsp; It returns true if the signature is valid, false otherwise.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig *Signature) Verify(hash []byte, pubKey *PublicKey) bool {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig *Signature) Verify(hash []byte, pubKey *PublicKey) bool {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ecdsa.Verify(pubKey.ToECDSA(), hash, sig.GetR(), sig.GetS())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ecdsa.Verify(pubKey.ToECDSA(), hash, sig.GetR(), sig.GetS())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// IsEqual compares this Signature instance to the one passed, returning true</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// IsEqual compares this Signature instance to the one passed, returning true</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// if both Signatures are equivalent. A signature is equivalent to another, if</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// if both Signatures are equivalent. A signature is equivalent to another, if</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// they both have the same scalar value for R and S.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// they both have the same scalar value for R and S.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig *Signature) IsEqual(otherSig *Signature) bool {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig *Signature) IsEqual(otherSig *Signature) bool {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.R.Cmp(otherSig.R) == 0 &amp;&amp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.R.Cmp(otherSig.R) == 0 &amp;&amp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sig.S.Cmp(otherSig.S) == 0</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sig.S.Cmp(otherSig.S) == 0</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func parseSig(sigStr []byte, curve elliptic.Curve, der bool) (*Signature, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func parseSig(sigStr []byte, curve elliptic.Curve, der bool) (*Signature, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Originally this code used encoding/asn1 in order to parse the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Originally this code used encoding/asn1 in order to parse the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// signature, but a number of problems were found with this approach.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// signature, but a number of problems were found with this approach.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Despite the fact that signatures are stored as DER, the difference</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Despite the fact that signatures are stored as DER, the difference</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// between go's idea of a bignum (and that they have sign) doesn't agree</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// between go's idea of a bignum (and that they have sign) doesn't agree</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// with the openssl one (where they do not). The above is true as of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// with the openssl one (where they do not). The above is true as of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Go 1.1. In the end it was simpler to rewrite the code to explicitly</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Go 1.1. In the end it was simpler to rewrite the code to explicitly</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// understand the format which is this:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// understand the format which is this:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30 &lt;length of whole message&gt; &lt;0x02&gt; &lt;length of R&gt; &lt;R&gt; 0x2</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30 &lt;length of whole message&gt; &lt;0x02&gt; &lt;length of R&gt; &lt;R&gt; 0x2</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// &lt;length of S&gt; &lt;S&gt;.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// &lt;length of S&gt; &lt;S&gt;.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature := &amp;Signature{}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature := &amp;Signature{}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// minimal message is when both numbers are 1 bytes. adding up to:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// minimal message is when both numbers are 1 bytes. adding up to:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30 + len + 0x02 + 0x01 + &lt;byte&gt; + 0x2 + 0x01 + &lt;byte&gt;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30 + len + 0x02 + 0x01 + &lt;byte&gt; + 0x2 + 0x01 + &lt;byte&gt;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(sigStr) &lt; 8 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(sigStr) &lt; 8 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: too short&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: too short&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x30</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index := 0</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index := 0</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x30 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x30 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: no header magic&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: no header magic&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// length of remaining message</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// length of remaining message</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; siglen := sigStr[index]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; siglen := sigStr[index]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if int(siglen+2) &gt; len(sigStr) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if int(siglen+2) &gt; len(sigStr) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bad length&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bad length&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// trim the slice we're working on so we only look at what matters.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// trim the slice we're working on so we only look at what matters.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sigStr = sigStr[:siglen+2]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sigStr = sigStr[:siglen+2]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x02</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x02</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x02 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x02 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errors.New(&quot;malformed signature: no 1st int marker&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errors.New(&quot;malformed signature: no 1st int marker&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Length of signature R.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Length of signature R.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rLen := int(sigStr[index])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rLen := int(sigStr[index])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// must be positive, must be able to fit in another 0x2, &lt;len&gt; &lt;s&gt;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// must be positive, must be able to fit in another 0x2, &lt;len&gt; &lt;s&gt;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hence the -3. We assume that the length must be at least one byte.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hence the -3. We assume that the length must be at least one byte.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if rLen &lt;= 0 || rLen &gt; len(sigStr)-index-3 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if rLen &lt;= 0 || rLen &gt; len(sigStr)-index-3 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bogus R length&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bogus R length&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Then R itself.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Then R itself.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rBytes := sigStr[index : index+rLen]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rBytes := sigStr[index : index+rLen]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if der {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if der {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch err := canonicalPadding(rBytes); err {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch err := canonicalPadding(rBytes); err {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errNegativeValue:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errNegativeValue:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is negative&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is negative&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errExcessivelyPaddedValue:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errExcessivelyPaddedValue:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is excessively padded&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is excessively padded&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature.R = new(big.Int).SetBytes(rBytes)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature.R = new(big.Int).SetBytes(rBytes)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index += rLen</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index += rLen</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x02. length already checked in previous if.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 0x02. length already checked in previous if.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x02 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sigStr[index] != 0x02 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: no 2nd int marker&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: no 2nd int marker&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Length of signature S.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Length of signature S.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sLen := int(sigStr[index])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sLen := int(sigStr[index])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// S should be the rest of the string.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// S should be the rest of the string.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sLen &lt;= 0 || sLen &gt; len(sigStr)-index {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if sLen &lt;= 0 || sLen &gt; len(sigStr)-index {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bogus S length&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;malformed signature: bogus S length&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Then S itself.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Then S itself.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sBytes := sigStr[index : index+sLen]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sBytes := sigStr[index : index+sLen]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if der {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if der {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch err := canonicalPadding(sBytes); err {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch err := canonicalPadding(sBytes); err {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errNegativeValue:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errNegativeValue:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is negative&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is negative&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errExcessivelyPaddedValue:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case errExcessivelyPaddedValue:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is excessively padded&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is excessively padded&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature.S = new(big.Int).SetBytes(sBytes)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; signature.S = new(big.Int).SetBytes(sBytes)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index += sLen</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; index += sLen</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// sanity check length parsing</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// sanity check length parsing</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if index != len(sigStr) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if index != len(sigStr) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, fmt.Errorf(&quot;malformed signature: bad final length %v != %v&quot;,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, fmt.Errorf(&quot;malformed signature: bad final length %v != %v&quot;,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index, len(sigStr))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index, len(sigStr))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Verify also checks this, but we can be more sure that we parsed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Verify also checks this, but we can be more sure that we parsed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// correctly if we verify here too.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// correctly if we verify here too.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// FWIW the ecdsa spec states that R and S must be | 1, N - 1 |</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// FWIW the ecdsa spec states that R and S must be | 1, N - 1 |</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// but crypto/ecdsa only checks for Sign != 0. Mirror that.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// but crypto/ecdsa only checks for Sign != 0. Mirror that.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.R.Sign() != 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.R.Sign() != 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R isn't 1 or more&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R isn't 1 or more&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.S.Sign() != 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.S.Sign() != 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S isn't 1 or more&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S isn't 1 or more&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.R.Cmp(curve.Params().N) &gt;= 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.R.Cmp(curve.Params().N) &gt;= 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is &gt;= curve.N&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature R is &gt;= curve.N&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.S.Cmp(curve.Params().N) &gt;= 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if signature.S.Cmp(curve.Params().N) &gt;= 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is &gt;= curve.N&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;signature S is &gt;= curve.N&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return signature, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return signature, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// ParseSignature parses a signature in BER format for the curve type `curve'</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// ParseSignature parses a signature in BER format for the curve type `curve'</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// into a Signature type, perfoming some basic sanity checks.&nbsp; If parsing</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// into a Signature type, perfoming some basic sanity checks.&nbsp; If parsing</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// according to the more strict DER format is needed, use ParseDERSignature.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// according to the more strict DER format is needed, use ParseDERSignature.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func ParseSignature(sigStr []byte, curve elliptic.Curve) (*Signature, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func ParseSignature(sigStr []byte, curve elliptic.Curve) (*Signature, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return parseSig(sigStr, curve, false)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return parseSig(sigStr, curve, false)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// ParseDERSignature parses a signature in DER format for the curve type</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// ParseDERSignature parses a signature in DER format for the curve type</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// `curve` into a Signature type.&nbsp; If parsing according to the less strict</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// `curve` into a Signature type.&nbsp; If parsing according to the less strict</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// BER format is needed, use ParseSignature.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// BER format is needed, use ParseSignature.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func ParseDERSignature(sigStr []byte, curve elliptic.Curve) (*Signature, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func ParseDERSignature(sigStr []byte, curve elliptic.Curve) (*Signature, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return parseSig(sigStr, curve, true)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return parseSig(sigStr, curve, true)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// canonicalizeInt returns the bytes for the passed big integer adjusted as</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// canonicalizeInt returns the bytes for the passed big integer adjusted as</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// necessary to ensure that a big-endian encoded integer can't possibly be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// necessary to ensure that a big-endian encoded integer can't possibly be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// misinterpreted as a negative number.&nbsp; This can happen when the most</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// misinterpreted as a negative number.&nbsp; This can happen when the most</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// significant bit is set, so it is padded by a leading zero byte in this case.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// significant bit is set, so it is padded by a leading zero byte in this case.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Also, the returned bytes will have at least a single byte when the passed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Also, the returned bytes will have at least a single byte when the passed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// value is 0.&nbsp; This is required for DER encoding.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// value is 0.&nbsp; This is required for DER encoding.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func canonicalizeInt(val *big.Int) []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func canonicalizeInt(val *big.Int) []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b := val.Bytes()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; b := val.Bytes()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(b) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(b) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b = []byte{0x00}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b = []byte{0x00}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if b[0]&amp;0x80 != 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if b[0]&amp;0x80 != 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paddedBytes := make([]byte, len(b)+1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paddedBytes := make([]byte, len(b)+1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(paddedBytes[1:], b)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(paddedBytes[1:], b)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b = paddedBytes</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; b = paddedBytes</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return b</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return b</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// canonicalPadding checks whether a big-endian encoded integer could</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// canonicalPadding checks whether a big-endian encoded integer could</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// possibly be misinterpreted as a negative number (even though OpenSSL</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// possibly be misinterpreted as a negative number (even though OpenSSL</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// treats all numbers as unsigned), or if there is any unnecessary</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// treats all numbers as unsigned), or if there is any unnecessary</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// leading zero padding.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// leading zero padding.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func canonicalPadding(b []byte) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func canonicalPadding(b []byte) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case b[0]&amp;0x80 == 0x80:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case b[0]&amp;0x80 == 0x80:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errNegativeValue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errNegativeValue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case len(b) &gt; 1 &amp;&amp; b[0] == 0x00 &amp;&amp; b[1]&amp;0x80 != 0x80:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case len(b) &gt; 1 &amp;&amp; b[0] == 0x00 &amp;&amp; b[1]&amp;0x80 != 0x80:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errExcessivelyPaddedValue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errExcessivelyPaddedValue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; default:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; default:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// hashToInt converts a hash value to an integer. There is some disagreement</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// hashToInt converts a hash value to an integer. There is some disagreement</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// about how this is done. [NSA] suggests that this is done in the obvious</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// about how this is done. [NSA] suggests that this is done in the obvious</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// manner, but [SECG] truncates the hash to the bit-length of the curve order</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// manner, but [SECG] truncates the hash to the bit-length of the curve order</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// first. We follow [SECG] because that's what OpenSSL does. Additionally,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// first. We follow [SECG] because that's what OpenSSL does. Additionally,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// OpenSSL right shifts excess bits from the number if the hash is too large</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// OpenSSL right shifts excess bits from the number if the hash is too large</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// and we mirror that too.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// and we mirror that too.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is borrowed from crypto/ecdsa.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is borrowed from crypto/ecdsa.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func hashToInt(hash []byte, c elliptic.Curve) *big.Int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func hashToInt(hash []byte, c elliptic.Curve) *big.Int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; orderBits := c.Params().N.BitLen()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; orderBits := c.Params().N.BitLen()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; orderBytes := (orderBits + 7) / 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; orderBytes := (orderBits + 7) / 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(hash) &gt; orderBytes {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(hash) &gt; orderBytes {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash = hash[:orderBytes]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash = hash[:orderBytes]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ret := new(big.Int).SetBytes(hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ret := new(big.Int).SetBytes(hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; excess := len(hash)*8 - orderBits</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; excess := len(hash)*8 - orderBits</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if excess &gt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if excess &gt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ret.Rsh(ret, uint(excess))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ret.Rsh(ret, uint(excess))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ret</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ret</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// recoverKeyFromSignature recoves a public key from the signature &quot;sig&quot; on the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// recoverKeyFromSignature recoves a public key from the signature &quot;sig&quot; on the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// given message hash &quot;msg&quot;. Based on the algorithm found in section 5.1.5 of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// given message hash &quot;msg&quot;. Based on the algorithm found in section 5.1.5 of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// SEC 1 Ver 2.0, page 47-48 (53 and 54 in the pdf). This performs the details</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// SEC 1 Ver 2.0, page 47-48 (53 and 54 in the pdf). This performs the details</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// in the inner loop in Step 1. The counter provided is actually the j parameter</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// in the inner loop in Step 1. The counter provided is actually the j parameter</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// of the loop * 2 - on the first iteration of j we do the R case, else the -R</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// of the loop * 2 - on the first iteration of j we do the R case, else the -R</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// case in step 1.6. This counter is used in the decred compressed signature</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// case in step 1.6. This counter is used in the decred compressed signature</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// format and thus we match bitcoind's behaviour here.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// format and thus we match bitcoind's behaviour here.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func recoverKeyFromSignature(curve *KoblitzCurve, sig *Signature, msg []byte,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func recoverKeyFromSignature(curve *KoblitzCurve, sig *Signature, msg []byte,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; iter int, doChecks bool) (*PublicKey, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; iter int, doChecks bool) (*PublicKey, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.1 x = (n * i) + r</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.1 x = (n * i) + r</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Rx := new(big.Int).Mul(curve.Params().N,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Rx := new(big.Int).Mul(curve.Params().N,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new(big.Int).SetInt64(int64(iter/2)))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new(big.Int).SetInt64(int64(iter/2)))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Rx.Add(Rx, sig.R)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Rx.Add(Rx, sig.R)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if Rx.Cmp(curve.Params().P) != -1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if Rx.Cmp(curve.Params().P) != -1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated Rx is larger than curve P&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated Rx is larger than curve P&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// convert 02&lt;Rx&gt; to point R. (step 1.2 and 1.3). If we are on an odd</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// convert 02&lt;Rx&gt; to point R. (step 1.2 and 1.3). If we are on an odd</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// iteration then 1.6 will be done with -R, so we calculate the other</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// iteration then 1.6 will be done with -R, so we calculate the other</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// term when uncompressing the point.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// term when uncompressing the point.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Ry, err := decompressPoint(curve, Rx, iter%2 == 1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Ry, err := decompressPoint(curve, Rx, iter%2 == 1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.4 Check n*R is point at infinity</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.4 Check n*R is point at infinity</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if doChecks {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if doChecks {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nRx, nRy := curve.ScalarMult(Rx, Ry, curve.Params().N.Bytes())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nRx, nRy := curve.ScalarMult(Rx, Ry, curve.Params().N.Bytes())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if nRx.Sign() != 0 || nRy.Sign() != 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if nRx.Sign() != 0 || nRy.Sign() != 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;n*R does not equal the point at infinity&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;n*R does not equal the point at infinity&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.5 calculate e from message using the same algorithm as ecdsa</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 1.5 calculate e from message using the same algorithm as ecdsa</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// signature calculation.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// signature calculation.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e := hashToInt(msg, curve)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e := hashToInt(msg, curve)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step 1.6.1:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step 1.6.1:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// We calculate the two terms sR and eG separately multiplied by the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// We calculate the two terms sR and eG separately multiplied by the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// inverse of r (from the signature). We then add them to calculate</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// inverse of r (from the signature). We then add them to calculate</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Q = r^-1(sR-eG)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Q = r^-1(sR-eG)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invr := new(big.Int).ModInverse(sig.R, curve.Params().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invr := new(big.Int).ModInverse(sig.R, curve.Params().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// first term.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// first term.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invrS := new(big.Int).Mul(invr, sig.S)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invrS := new(big.Int).Mul(invr, sig.S)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invrS.Mod(invrS, curve.Params().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; invrS.Mod(invrS, curve.Params().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sRx, sRy := curve.ScalarMult(Rx, Ry, invrS.Bytes())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sRx, sRy := curve.ScalarMult(Rx, Ry, invrS.Bytes())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// second term.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// second term.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Neg(e)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Neg(e)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mod(e, curve.Params().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mod(e, curve.Params().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mul(e, invr)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mul(e, invr)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mod(e, curve.Params().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e.Mod(e, curve.Params().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; minuseGx, minuseGy := curve.ScalarBaseMult(e.Bytes())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; minuseGx, minuseGy := curve.ScalarBaseMult(e.Bytes())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// TODO(oga) this would be faster if we did a mult and add in one</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// TODO(oga) this would be faster if we did a mult and add in one</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// step to prevent the jacobian conversion back and forth.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// step to prevent the jacobian conversion back and forth.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Qx, Qy := curve.Add(sRx, sRy, minuseGx, minuseGy)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; Qx, Qy := curve.Add(sRx, sRy, minuseGx, minuseGy)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;PublicKey{</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;PublicKey{</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Curve: curve,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Curve: curve,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; X:&nbsp; &nbsp;&nbsp; Qx,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; X:&nbsp; &nbsp;&nbsp; Qx,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Y:&nbsp; &nbsp;&nbsp; Qy,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Y:&nbsp; &nbsp;&nbsp; Qy,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// SignCompact produces a compact signature of the data in hash with the given</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// SignCompact produces a compact signature of the data in hash with the given</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// private key on the given koblitz curve. The isCompressed&nbsp; parameter should</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// private key on the given koblitz curve. The isCompressed&nbsp; parameter should</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// be used to detail if the given signature should reference a compressed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// be used to detail if the given signature should reference a compressed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// public key or not. If successful the bytes of the compact signature will be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// public key or not. If successful the bytes of the compact signature will be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// returned in the format:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// returned in the format:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// &lt;(byte of 27+public key solution)+4 if compressed &gt;&lt; padded bytes for signature R&gt;&lt;padded bytes for signature S&gt;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// &lt;(byte of 27+public key solution)+4 if compressed &gt;&lt; padded bytes for signature R&gt;&lt;padded bytes for signature S&gt;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// where the R and S parameters are padde up to the bitlengh of the curve.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// where the R and S parameters are padde up to the bitlengh of the curve.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func SignCompact(curve *KoblitzCurve, key *PrivateKey,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func SignCompact(curve *KoblitzCurve, key *PrivateKey,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash []byte, isCompressedKey bool) ([]byte, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash []byte, isCompressedKey bool) ([]byte, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sig, err := key.Sign(hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sig, err := key.Sign(hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// bitcoind checks the bit length of R and S here. The ecdsa signature</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// bitcoind checks the bit length of R and S here. The ecdsa signature</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// algorithm returns R and S mod N therefore they will be the bitsize of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// algorithm returns R and S mod N therefore they will be the bitsize of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the curve, and thus correctly sized.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the curve, and thus correctly sized.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := 0; i &lt; (curve.H+1)*2; i++ {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := 0; i &lt; (curve.H+1)*2; i++ {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk, err := recoverKeyFromSignature(curve, sig, hash, i, true)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pk, err := recoverKeyFromSignature(curve, sig, hash, i, true)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err == nil &amp;&amp; pk.X.Cmp(key.X) == 0 &amp;&amp; pk.Y.Cmp(key.Y) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err == nil &amp;&amp; pk.X.Cmp(key.X) == 0 &amp;&amp; pk.Y.Cmp(key.Y) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result := make([]byte, 1, 2*curve.byteSize+1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result := make([]byte, 1, 2*curve.byteSize+1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = 27 + byte(i)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = 27 + byte(i)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isCompressedKey {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isCompressedKey {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] += 4</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] += 4</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Not sure this needs rounding but safer to do so.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Not sure this needs rounding but safer to do so.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curvelen := (curve.BitSize + 7) / 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curvelen := (curve.BitSize + 7) / 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Pad R and S to curvelen if needed.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Pad R and S to curvelen if needed.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bytelen := (sig.R.BitLen() + 7) / 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bytelen := (sig.R.BitLen() + 7) / 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if bytelen &lt; curvelen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if bytelen &lt; curvelen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; make([]byte, curvelen-bytelen)...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; make([]byte, curvelen-bytelen)...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result, sig.R.Bytes()...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result, sig.R.Bytes()...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bytelen = (sig.S.BitLen() + 7) / 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bytelen = (sig.S.BitLen() + 7) / 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if bytelen &lt; curvelen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if bytelen &lt; curvelen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; make([]byte, curvelen-bytelen)...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; make([]byte, curvelen-bytelen)...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result, sig.S.Bytes()...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result = append(result, sig.S.Bytes()...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;no valid solution for pubkey found&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;no valid solution for pubkey found&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// RecoverCompact verifies the compact signature &quot;signature&quot; of &quot;hash&quot; for the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// RecoverCompact verifies the compact signature &quot;signature&quot; of &quot;hash&quot; for the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Koblitz curve in &quot;curve&quot;. If the signature matches then the recovered public</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Koblitz curve in &quot;curve&quot;. If the signature matches then the recovered public</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// key will be returned as well as a boolen if the original key was compressed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// key will be returned as well as a boolen if the original key was compressed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// or not, else an error will be returned.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// or not, else an error will be returned.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func RecoverCompact(curve *KoblitzCurve, signature,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func RecoverCompact(curve *KoblitzCurve, signature,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash []byte) (*PublicKey, bool, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash []byte) (*PublicKey, bool, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bitlen := (curve.BitSize + 7) / 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bitlen := (curve.BitSize + 7) / 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(signature) != 1+bitlen*2 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(signature) != 1+bitlen*2 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, false, errors.New(&quot;invalid compact signature size&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, false, errors.New(&quot;invalid compact signature size&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; iteration := int((signature[0] - 27) &amp; ^byte(4))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; iteration := int((signature[0] - 27) &amp; ^byte(4))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// format is &lt;header byte&gt;&lt;bitlen R&gt;&lt;bitlen S&gt;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// format is &lt;header byte&gt;&lt;bitlen R&gt;&lt;bitlen S&gt;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sig := &amp;Signature{</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; sig := &amp;Signature{</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; R: new(big.Int).SetBytes(signature[1 : bitlen+1]),</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; R: new(big.Int).SetBytes(signature[1 : bitlen+1]),</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; S: new(big.Int).SetBytes(signature[bitlen+1:]),</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; S: new(big.Int).SetBytes(signature[bitlen+1:]),</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The iteration used here was encoded</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The iteration used here was encoded</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; key, err := recoverKeyFromSignature(curve, sig, hash, iteration, false)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; key, err := recoverKeyFromSignature(curve, sig, hash, iteration, false)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, false, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, false, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return key, ((signature[0] - 27) &amp; 4) == 4, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return key, ((signature[0] - 27) &amp; 4) == 4, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// signRFC6979 generates a deterministic ECDSA signature according to RFC 6979</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// signRFC6979 generates a deterministic ECDSA signature according to RFC 6979</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// and BIP 62.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// and BIP 62.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func signRFC6979(privateKey *PrivateKey, hash []byte) (*Signature, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func signRFC6979(privateKey *PrivateKey, hash []byte) (*Signature, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; privkey := privateKey.ToECDSA()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; privkey := privateKey.ToECDSA()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; N := order</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; N := order</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k := NonceRFC6979(privkey.D, hash, nil, nil)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k := NonceRFC6979(privkey.D, hash, nil, nil)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; inv := new(big.Int).ModInverse(k, N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; inv := new(big.Int).ModInverse(k, N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; r, _ := privkey.Curve.ScalarBaseMult(k.Bytes())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; r, _ := privkey.Curve.ScalarBaseMult(k.Bytes())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if r.Cmp(N) == 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if r.Cmp(N) == 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.Sub(r, N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.Sub(r, N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if r.Sign() == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if r.Sign() == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated R is zero&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated R is zero&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e := hashToInt(hash, privkey.Curve)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; e := hashToInt(hash, privkey.Curve)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s := new(big.Int).Mul(privkey.D, r)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s := new(big.Int).Mul(privkey.D, r)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Add(s, e)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Add(s, e)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Mul(s, inv)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Mul(s, inv)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Mod(s, N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; s.Mod(s, N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if s.Cmp(halforder) == 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if s.Cmp(halforder) == 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s.Sub(N, s)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s.Sub(N, s)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if s.Sign() == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if s.Sign() == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated S is zero&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, errors.New(&quot;calculated S is zero&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;Signature{R: r, S: s}, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;Signature{R: r, S: s}, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NonceRFC6979 generates an ECDSA nonce (`k`) deterministically according to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NonceRFC6979 generates an ECDSA nonce (`k`) deterministically according to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// RFC 6979. It takes a 32-byte hash as an input and returns 32-byte nonce to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// RFC 6979. It takes a 32-byte hash as an input and returns 32-byte nonce to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// be used in ECDSA algorithm.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// be used in ECDSA algorithm.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func NonceRFC6979(privkey *big.Int, hash []byte, extra []byte,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func NonceRFC6979(privkey *big.Int, hash []byte, extra []byte,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; version []byte) *big.Int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; version []byte) *big.Int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curve := S256()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curve := S256()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; q := curve.Params().N</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; q := curve.Params().N</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; x := privkey</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; x := privkey</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; alg := sha256.New</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; alg := sha256.New</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; qlen := q.BitLen()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; qlen := q.BitLen()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; holen := alg().Size()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; holen := alg().Size()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rolen := (qlen + 7) &gt;&gt; 3</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; rolen := (qlen + 7) &gt;&gt; 3</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bx := append(int2octets(x, rolen), bits2octets(hash, curve, rolen)...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bx := append(int2octets(x, rolen), bits2octets(hash, curve, rolen)...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(extra) == 32 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(extra) == 32 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, extra...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, extra...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(version) == 16 &amp;&amp; len(extra) == 32 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(version) == 16 &amp;&amp; len(extra) == 32 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, extra...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, extra...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(version) == 16 &amp;&amp; len(extra) != 32 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(version) == 16 &amp;&amp; len(extra) != 32 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, bytes.Repeat([]byte{0x00}, 32)...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, bytes.Repeat([]byte{0x00}, 32)...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, version...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bx = append(bx, version...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step B</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step B</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v := bytes.Repeat(oneInitializer, holen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v := bytes.Repeat(oneInitializer, holen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step C (Go zeroes the all allocated memory)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step C (Go zeroes the all allocated memory)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k := make([]byte, holen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k := make([]byte, holen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step D</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step D</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(append(v, 0x00), bx...))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(append(v, 0x00), bx...))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step E</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step E</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step F</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step F</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(append(v, 0x01), bx...))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(append(v, 0x01), bx...))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step G</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step G</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H1</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H1</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var t []byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var t []byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H2</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H2</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for len(t)*8 &lt; qlen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for len(t)*8 &lt; qlen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; t = append(t, v...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; t = append(t, v...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H3</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Step H3</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; secret := hashToInt(t, curve)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; secret := hashToInt(t, curve)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if secret.Cmp(one) &gt;= 0 &amp;&amp; secret.Cmp(q) &lt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if secret.Cmp(one) &gt;= 0 &amp;&amp; secret.Cmp(q) &lt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return secret</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return secret</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(v, 0x00))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; k = mac(alg, k, append(v, 0x00))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; v = mac(alg, k, v)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// mac returns an HMAC of the given key and message.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// mac returns an HMAC of the given key and message.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func mac(alg func() hash.Hash, k, m []byte) []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func mac(alg func() hash.Hash, k, m []byte) []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; h := hmac.New(alg, k)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; h := hmac.New(alg, k)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; h.Write(m)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; h.Write(m)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return h.Sum(nil)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return h.Sum(nil)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// https://tools.ietf.org/html/rfc6979#section-2.3.3</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// https://tools.ietf.org/html/rfc6979#section-2.3.3</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func int2octets(v *big.Int, rolen int) []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func int2octets(v *big.Int, rolen int) []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; out := v.Bytes()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; out := v.Bytes()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// left pad with zeros if it's too short</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// left pad with zeros if it's too short</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(out) &lt; rolen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(out) &lt; rolen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; out2 := make([]byte, rolen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; out2 := make([]byte, rolen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(out2[rolen-len(out):], out)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(out2[rolen-len(out):], out)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return out2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return out2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// drop most significant bytes if it's too long</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// drop most significant bytes if it's too long</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(out) &gt; rolen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(out) &gt; rolen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; out2 := make([]byte, rolen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; out2 := make([]byte, rolen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(out2, out[len(out)-rolen:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(out2, out[len(out)-rolen:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return out2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return out2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return out</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return out</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// https://tools.ietf.org/html/rfc6979#section-2.3.4</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// https://tools.ietf.org/html/rfc6979#section-2.3.4</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func bits2octets(in []byte, curve elliptic.Curve, rolen int) []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func bits2octets(in []byte, curve elliptic.Curve, rolen int) []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; z1 := hashToInt(in, curve)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; z1 := hashToInt(in, curve)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; z2 := new(big.Int).Sub(z1, curve.Params().N)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; z2 := new(big.Int).Sub(z1, curve.Params().N)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if z2.Sign() &lt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if z2.Sign() &lt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return int2octets(z1, rolen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return int2octets(z1, rolen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return int2octets(z2, rolen)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return int2octets(z2, rolen)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// GetR satisfies the chainec PublicKey interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// GetR satisfies the chainec PublicKey interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig Signature) GetR() *big.Int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig Signature) GetR() *big.Int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.R</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.R</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// GetS satisfies the chainec PublicKey interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// GetS satisfies the chainec PublicKey interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig Signature) GetS() *big.Int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig Signature) GetS() *big.Int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.S</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return sig.S</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// GetType satisfies the chainec Signature interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// GetType satisfies the chainec Signature interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (sig Signature) GetType() int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (sig Signature) GetType() int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ecTypeSecp256k1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return ecTypeSecp256k1</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
</table>
<br/>
</body>
</html>
