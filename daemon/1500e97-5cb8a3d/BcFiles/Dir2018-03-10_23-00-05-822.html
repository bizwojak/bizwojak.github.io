<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style>
.AlignLeft { text-align: left; }
.AlignCenter { text-align: center; }
.AlignRight { text-align: right; }
body { font-family: sans-serif; font-size: 11pt; }
img.AutoScale { max-width: 100%; max-height: 100%; }
td { vertical-align: top; padding-left: 4px; padding-right: 4px; }

tr.SectionGap td { font-size: 4px; border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionBegin td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionMiddle td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SubsectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
tr.SubsectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
table.fc { border-top: 1px solid Black; border-left: 1px solid Black; width: 100%; font-family: monospace; font-size: 10pt; }
td.TextItemInsigMod { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigOrphan { color: #000000; background-color: #FAEEFF; }
td.TextItemNum { color: #696969; background-color: #F0F0F0; }
td.TextItemSame { color: #000000; background-color: #FFFFFF; }
td.TextItemSigMod { color: #000000; background-color: #FFE3E3; }
td.TextItemSigOrphan { color: #000000; background-color: #F1E3FF; }
.TextSegInsigDiff { color: #0000FF; }
.TextSegReplacedDiff { color: #0000FF; font-style: italic; }
.TextSegSigDiff { color: #FF0000; }
td.TextItemInsigAdd { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigDel { color: #000000; background-color: #EEEEFF; text-decoration: line-through; }
td.TextItemSigAdd { color: #000000; background-color: #FFE3E3; }
td.TextItemSigDel { color: #000000; background-color: #FFE3E3; text-decoration: line-through; }
.TextSegElementComment { color: #786A41; }
.TextSegElementBranding { }
</style>
<title>dcrd-1.1.0 <--> hxd-rc1.0 Comparison</title>
</head>
<body>
dcrd-1.1.0 <--> hxd-rc1.0 Comparison<br/>
Produced: 10/3/2018 11:00:05 PM<br/>
&nbsp; &nbsp;
<br/>
Mode:&nbsp; All, Ignoring Unimportant &nbsp;
<br/>
Left file: dcrd-1.1.0\blockchain\indexers\addrindex.go &nbsp;
<br/>
Right file: hxd-rc1.0\blockchain\indexers\addrindex.go &nbsp;
<br/>
<table class="fc" cellspacing="0" cellpadding="0">
<tr class="SectionBegin">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2016 The btcsuite developers</span></td>
<td class="AlignCenter">=</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2016 The btcsuite developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2016-2017 The Decred developers</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2016-2017 The Decred developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">package indexers</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">package indexers</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">import (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">import (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;errors&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;errors&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;fmt&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;fmt&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;sync&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;sync&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/blockchain&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/blockchain&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/blockchain/stake&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/blockchain/stake&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/chaincfg&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/chaincfg&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/chaincfg/chainec&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/chaincfg/chainec&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/chaincfg/chainhash&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/chaincfg/chainhash&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/database&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/database&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/txscript&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/txscript&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/wire&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/wire&quot;</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementBranding">&quot;github.com/</span><span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red/dcr</span><span class="TextSegElementBranding">util&quot;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementBranding">dcrutil </span><span class="TextSegElementBranding">&quot;github.com/</span><span class="TextSegElementBranding">hybridnetwork</span><span class="TextSegElementBranding">/hx</span><span class="TextSegElementBranding">util&quot;</span></td>
</tr>
<tr class="SectionAll">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">-+</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">&quot;github.com/</span>hybridnetwork<span class="TextSegSigDiff">/</span>hx<span class="TextSegSigDiff">d/crypto/bliss&quot;</span></td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">)</td>
<td class="AlignCenter">=</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">const (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">const (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrIndexName is the human-readable name for the index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrIndexName is the human-readable name for the index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIndexName = &quot;address index&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIndexName = &quot;address index&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level0MaxEntries is the maximum number of transactions that are</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level0MaxEntries is the maximum number of transactions that are</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// stored in level 0 of an address index entry.&nbsp; Subsequent levels store</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// stored in level 0 of an address index entry.&nbsp; Subsequent levels store</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 2^n * level0MaxEntries entries, or in words, double the maximum of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// 2^n * level0MaxEntries entries, or in words, double the maximum of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the previous level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the previous level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0MaxEntries = 8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0MaxEntries = 8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeySize is the number of bytes an address key consumes in the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeySize is the number of bytes an address key consumes in the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.&nbsp; It consists of 1 byte address type + 20 bytes hash160.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.&nbsp; It consists of 1 byte address type + 20 bytes hash160.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeySize = 1 + 20</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeySize = 1 + 20</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levelKeySize is the number of bytes a level key in the address index</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levelKeySize is the number of bytes a level key in the address index</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// consumes.&nbsp; It consists of the address key + 1 byte for the level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// consumes.&nbsp; It consists of the address key + 1 byte for the level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; levelKeySize = addrKeySize + 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; levelKeySize = addrKeySize + 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levelOffset is the offset in the level key which identifes the level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levelOffset is the offset in the level key which identifes the level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; levelOffset = levelKeySize - 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; levelOffset = levelKeySize - 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHash is the address type in an address key which</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHash is the address type in an address key which</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// represents both a pay-to-pubkey-hash and a pay-to-pubkey address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// represents both a pay-to-pubkey-hash and a pay-to-pubkey address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This is done because both are identical for the purposes of the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This is done because both are identical for the purposes of the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHash = 0</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHash = 0</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHashEdwards is the address type in an address key</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHashEdwards is the address type in an address key</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which represents both a pay-to-pubkey-hash and a pay-to-pubkey-alt</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which represents both a pay-to-pubkey-hash and a pay-to-pubkey-alt</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address using Schnorr signatures over the Ed25519 curve.&nbsp; This is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address using Schnorr signatures over the Ed25519 curve.&nbsp; This is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// done because both are identical for the purposes of the address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// done because both are identical for the purposes of the address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHashEdwards = 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHashEdwards = 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHashSchnorr is the address type in an address key</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHashSchnorr is the address type in an address key</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which represents both a pay-to-pubkey-hash and a pay-to-pubkey-alt</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which represents both a pay-to-pubkey-hash and a pay-to-pubkey-alt</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address using Schnorr signatures over the secp256k1 curve.&nbsp; This is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address using Schnorr signatures over the secp256k1 curve.&nbsp; This is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// done because both are identical for the purposes of the address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// done because both are identical for the purposes of the address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHashSchnorr = 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypePubKeyHashSchnorr = 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypeScriptHash is the address type in an address key which</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypeScriptHash is the address type in an address key which</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// represents a pay-to-script-hash address.&nbsp; This is necessary because</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// represents a pay-to-script-hash address.&nbsp; This is necessary because</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the hash of a pubkey address might be the same as that of a script</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the hash of a pubkey address might be the same as that of a script</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hash.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hash.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypeScriptHash = 3</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKeyTypeScriptHash = 3</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrKeyTypePubKeyHashBliss is the address type in an address key which</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// represents both a bliss pay-to-pubkey-hash and a bliss pay-to-pubkey address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This is done because both are identical for the purposes of the</span></td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address index.</span></td>
</tr>
<tr class="SectionAll">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">-+</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">addrKeyTypePubKeyHashBliss</span> <span class="TextSegSigDiff">=</span> <span class="TextSegSigDiff">4</span></td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">=</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Size of a transaction entry.&nbsp; It consists of 4 bytes block id + 4</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Size of a transaction entry.&nbsp; It consists of 4 bytes block id + 4</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// bytes offset + 4 bytes length.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// bytes offset + 4 bytes length.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; txEntrySize = 4 + 4 + 4</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; txEntrySize = 4 + 4 + 4</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">var (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">var (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrIndexKey is the key of the address index and the db bucket used</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addrIndexKey is the key of the address index and the db bucket used</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to house it.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to house it.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIndexKey = []byte(&quot;txbyaddridx&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIndexKey = []byte(&quot;txbyaddridx&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// errUnsupportedAddressType is an error that is used to signal an</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// errUnsupportedAddressType is an error that is used to signal an</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// unsupported address type has been used.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// unsupported address type has been used.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errUnsupportedAddressType = errors.New(&quot;address type is not supported &quot; +</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; errUnsupportedAddressType = errors.New(&quot;address type is not supported &quot; +</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;by the address index&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;by the address index&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// -----------------------------------------------------------------------------</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// -----------------------------------------------------------------------------</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The address index maps addresses referenced in the blockchain to a list of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The address index maps addresses referenced in the blockchain to a list of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// all the transactions involving that address.&nbsp; Transactions are stored</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// all the transactions involving that address.&nbsp; Transactions are stored</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// according to their order of appearance in the blockchain.&nbsp; That is to say</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// according to their order of appearance in the blockchain.&nbsp; That is to say</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// first by block height and then by offset inside the block.&nbsp; It is also</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// first by block height and then by offset inside the block.&nbsp; It is also</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// important to note that this implementation requires the transaction index</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// important to note that this implementation requires the transaction index</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// since it is needed in order to catch up old blocks due to the fact the spent</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// since it is needed in order to catch up old blocks due to the fact the spent</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// outputs will already be pruned from the utxo set.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// outputs will already be pruned from the utxo set.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The approach used to store the index is similar to a log-structured merge</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The approach used to store the index is similar to a log-structured merge</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// tree (LSM tree) and is thus similar to how leveldb works internally.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// tree (LSM tree) and is thus similar to how leveldb works internally.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Every address consists of one or more entries identified by a level starting</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Every address consists of one or more entries identified by a level starting</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// from 0 where each level holds a maximum number of entries such that each</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// from 0 where each level holds a maximum number of entries such that each</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// subsequent level holds double the maximum of the previous one.&nbsp; In equation</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// subsequent level holds double the maximum of the previous one.&nbsp; In equation</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// form, the number of entries each level holds is 2^n * firstLevelMaxSize.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// form, the number of entries each level holds is 2^n * firstLevelMaxSize.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// New transactions are appended to level 0 until it becomes full at which point</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// New transactions are appended to level 0 until it becomes full at which point</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// the entire level 0 entry is appended to the level 1 entry and level 0 is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// the entire level 0 entry is appended to the level 1 entry and level 0 is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// cleared.&nbsp; This process continues until level 1 becomes full at which point it</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// cleared.&nbsp; This process continues until level 1 becomes full at which point it</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// will be appended to level 2 and cleared and so on.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// will be appended to level 2 and cleared and so on.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The result of this is the lower levels contain newer transactions and the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The result of this is the lower levels contain newer transactions and the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transactions within each level are ordered from oldest to newest.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transactions within each level are ordered from oldest to newest.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The intent of this approach is to provide a balance between space efficiency</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The intent of this approach is to provide a balance between space efficiency</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// and indexing cost.&nbsp; Storing one entry per transaction would have the lowest</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// and indexing cost.&nbsp; Storing one entry per transaction would have the lowest</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// indexing cost, but would waste a lot of space because the same address hash</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// indexing cost, but would waste a lot of space because the same address hash</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// would be duplicated for every transaction key.&nbsp; On the other hand, storing a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// would be duplicated for every transaction key.&nbsp; On the other hand, storing a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// single entry with all transactions would be the most space efficient, but</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// single entry with all transactions would be the most space efficient, but</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// would cause indexing cost to grow quadratically with the number of</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// would cause indexing cost to grow quadratically with the number of</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transactions involving the same address.&nbsp; The approach used here provides</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transactions involving the same address.&nbsp; The approach used here provides</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// logarithmic insertion and retrieval.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// logarithmic insertion and retrieval.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The serialized key format is:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The serialized key format is:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; &lt;addr type&gt;&lt;addr hash&gt;&lt;level&gt;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; &lt;addr type&gt;&lt;addr hash&gt;&lt;level&gt;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Field&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Type&nbsp; &nbsp; &nbsp; Size</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Field&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Type&nbsp; &nbsp; &nbsp; Size</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; addr type&nbsp; &nbsp; &nbsp;&nbsp; uint8&nbsp; &nbsp;&nbsp; 1 byte</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; addr type&nbsp; &nbsp; &nbsp;&nbsp; uint8&nbsp; &nbsp;&nbsp; 1 byte</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; addr hash&nbsp; &nbsp; &nbsp;&nbsp; hash160&nbsp;&nbsp; 20 bytes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; addr hash&nbsp; &nbsp; &nbsp;&nbsp; hash160&nbsp;&nbsp; 20 bytes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; level&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint8&nbsp; &nbsp;&nbsp; 1 byte</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; level&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint8&nbsp; &nbsp;&nbsp; 1 byte</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; -----</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; -----</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Total: 22 bytes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Total: 22 bytes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The serialized value format is:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The serialized value format is:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; [&lt;block id&gt;&lt;start offset&gt;&lt;tx length&gt;,...]</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; [&lt;block id&gt;&lt;start offset&gt;&lt;tx length&gt;,...]</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Field&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Type&nbsp; &nbsp; &nbsp; Size</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Field&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Type&nbsp; &nbsp; &nbsp; Size</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; block id&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; block id&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; start offset&nbsp; &nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; start offset&nbsp; &nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; tx length&nbsp; &nbsp; &nbsp;&nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; tx length&nbsp; &nbsp; &nbsp;&nbsp; uint32&nbsp; &nbsp; 4 bytes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; -----</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; -----</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Total: 12 bytes per indexed tx</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp;&nbsp; Total: 12 bytes per indexed tx</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// -----------------------------------------------------------------------------</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// -----------------------------------------------------------------------------</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// fetchBlockHashFunc defines a callback function to use in order to convert a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// fetchBlockHashFunc defines a callback function to use in order to convert a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// serialized block ID to an associated block hash.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// serialized block ID to an associated block hash.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">type fetchBlockHashFunc func(serializedID []byte) (*chainhash.Hash, error)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">type fetchBlockHashFunc func(serializedID []byte) (*chainhash.Hash, error)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// serializeAddrIndexEntry serializes the provided block id and transaction</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// serializeAddrIndexEntry serializes the provided block id and transaction</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// location according to the format described in detail above.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// location according to the format described in detail above.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func serializeAddrIndexEntry(blockID uint32, txLoc wire.TxLoc) []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func serializeAddrIndexEntry(blockID uint32, txLoc wire.TxLoc) []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Serialize the entry.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Serialize the entry.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; serialized := make([]byte, 12)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; serialized := make([]byte, 12)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized, blockID)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized, blockID)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized[4:], uint32(txLoc.TxStart))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized[4:], uint32(txLoc.TxStart))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized[8:], uint32(txLoc.TxLen))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; byteOrder.PutUint32(serialized[8:], uint32(txLoc.TxLen))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return serialized</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return serialized</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// deserializeAddrIndexEntry decodes the passed serialized byte slice into the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// deserializeAddrIndexEntry decodes the passed serialized byte slice into the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// provided region struct according to the format described in detail above and</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// provided region struct according to the format described in detail above and</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// uses the passed block hash fetching function in order to conver the block ID</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// uses the passed block hash fetching function in order to conver the block ID</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// to the associated block hash.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// to the associated block hash.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func deserializeAddrIndexEntry(serialized []byte, region *database.BlockRegion, fetchBlockHash fetchBlockHashFunc) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func deserializeAddrIndexEntry(serialized []byte, region *database.BlockRegion, fetchBlockHash fetchBlockHashFunc) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure there are enough bytes to decode.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure there are enough bytes to decode.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(serialized) &lt; txEntrySize {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(serialized) &lt; txEntrySize {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errDeserialize(&quot;unexpected end of data&quot;)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return errDeserialize(&quot;unexpected end of data&quot;)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash, err := fetchBlockHash(serialized[0:4])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; hash, err := fetchBlockHash(serialized[0:4])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Hash = hash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Hash = hash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Offset = byteOrder.Uint32(serialized[4:8])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Offset = byteOrder.Uint32(serialized[4:8])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Len = byteOrder.Uint32(serialized[8:12])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; region.Len = byteOrder.Uint32(serialized[8:12])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// keyForLevel returns the key for a specific address and level in the address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// keyForLevel returns the key for a specific address and level in the address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// index entry.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// index entry.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func keyForLevel(addrKey [addrKeySize]byte, level uint8) [levelKeySize]byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func keyForLevel(addrKey [addrKeySize]byte, level uint8) [levelKeySize]byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var key [levelKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var key [levelKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(key[:], addrKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(key[:], addrKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; key[levelOffset] = level</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; key[levelOffset] = level</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return key</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return key</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// dbPutAddrIndexEntry updates the address index to include the provided entry</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// dbPutAddrIndexEntry updates the address index to include the provided entry</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// according to the level-based scheme described in detail above.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// according to the level-based scheme described in detail above.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func dbPutAddrIndexEntry(bucket internalBucket, addrKey [addrKeySize]byte, blockID uint32, txLoc wire.TxLoc) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func dbPutAddrIndexEntry(bucket internalBucket, addrKey [addrKeySize]byte, blockID uint32, txLoc wire.TxLoc) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start with level 0 and its initial max number of entries.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start with level 0 and its initial max number of entries.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevel := uint8(0)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevel := uint8(0)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; maxLevelBytes := level0MaxEntries * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; maxLevelBytes := level0MaxEntries * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Simply append the new entry to level 0 and return now when it will</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Simply append the new entry to level 0 and return now when it will</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// fit.&nbsp; This is the most common path.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// fit.&nbsp; This is the most common path.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; newData := serializeAddrIndexEntry(blockID, txLoc)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; newData := serializeAddrIndexEntry(blockID, txLoc)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0Key := keyForLevel(addrKey, 0)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0Key := keyForLevel(addrKey, 0)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0Data := bucket.Get(level0Key[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; level0Data := bucket.Get(level0Key[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(level0Data)+len(newData) &lt;= maxLevelBytes {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(level0Data)+len(newData) &lt;= maxLevelBytes {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData := newData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData := newData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(level0Data) &gt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(level0Data) &gt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData = make([]byte, len(level0Data)+len(newData))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData = make([]byte, len(level0Data)+len(newData))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData, level0Data)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData, level0Data)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData[len(level0Data):], newData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData[len(level0Data):], newData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return bucket.Put(level0Key[:], mergedData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return bucket.Put(level0Key[:], mergedData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point, level 0 is full, so merge each level into higher</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point, level 0 is full, so merge each level into higher</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levels as many times as needed to free up level 0.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// levels as many times as needed to free up level 0.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; prevLevelData := level0Data</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; prevLevelData := level0Data</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Each new level holds twice as much as the previous one.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Each new level holds twice as much as the previous one.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevel++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevel++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxLevelBytes *= 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxLevelBytes *= 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Move to the next level as long as the current level is full.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Move to the next level as long as the current level is full.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, curLevel)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, curLevel)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData := bucket.Get(curLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData := bucket.Get(curLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == maxLevelBytes {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == maxLevelBytes {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelData = curLevelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelData = curLevelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The current level has room for the data in the previous one,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The current level has room for the data in the previous one,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// so merge the data from previous level into it.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// so merge the data from previous level into it.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData := prevLevelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData := prevLevelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) &gt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) &gt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData = make([]byte, len(curLevelData)+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergedData = make([]byte, len(curLevelData)+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len(prevLevelData))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len(prevLevelData))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData, curLevelData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData, curLevelData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData[len(curLevelData):], prevLevelData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(mergedData[len(curLevelData):], prevLevelData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(curLevelKey[:], mergedData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(curLevelKey[:], mergedData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Move all of the levels before the previous one up a level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Move all of the levels before the previous one up a level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for mergeLevel := curLevel - 1; mergeLevel &gt; 0; mergeLevel-- {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for mergeLevel := curLevel - 1; mergeLevel &gt; 0; mergeLevel-- {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergeLevelKey := keyForLevel(addrKey, mergeLevel)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mergeLevelKey := keyForLevel(addrKey, mergeLevel)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelKey := keyForLevel(addrKey, mergeLevel-1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelKey := keyForLevel(addrKey, mergeLevel-1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevData := bucket.Get(prevLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevData := bucket.Get(prevLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(mergeLevelKey[:], prevData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(mergeLevelKey[:], prevData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Finally, insert the new entry into level 0 now that it is empty.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Finally, insert the new entry into level 0 now that it is empty.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return bucket.Put(level0Key[:], newData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return bucket.Put(level0Key[:], newData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// dbFetchAddrIndexEntries returns block regions for transactions referenced by</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// dbFetchAddrIndexEntries returns block regions for transactions referenced by</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// the given address key and the number of entries skipped since it could have</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// the given address key and the number of entries skipped since it could have</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// been less in the case where there are less total entries than the requested</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// been less in the case where there are less total entries than the requested</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// number of entries to skip.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// number of entries to skip.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func dbFetchAddrIndexEntries(bucket internalBucket, addrKey [addrKeySize]byte, numToSkip, numRequested uint32, reverse bool, fetchBlockHash fetchBlockHashFunc) ([]database.BlockRegion, uint32, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func dbFetchAddrIndexEntries(bucket internalBucket, addrKey [addrKeySize]byte, numToSkip, numRequested uint32, reverse bool, fetchBlockHash fetchBlockHashFunc) ([]database.BlockRegion, uint32, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the reverse flag is not set, all levels need to be fetched</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the reverse flag is not set, all levels need to be fetched</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// because numToSkip and numRequested are counted from the oldest</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// because numToSkip and numRequested are counted from the oldest</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transactions (highest level) and thus the total count is needed.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transactions (highest level) and thus the total count is needed.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// However, when the reverse flag is set, only enough records to satisfy</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// However, when the reverse flag is set, only enough records to satisfy</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the requested amount are needed.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the requested amount are needed.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var level uint8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var level uint8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var serialized []byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var serialized []byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for !reverse || len(serialized) &lt; int(numToSkip+numRequested)*txEntrySize {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for !reverse || len(serialized) &lt; int(numToSkip+numRequested)*txEntrySize {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData := bucket.Get(curLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData := bucket.Get(curLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if levelData == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if levelData == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Stop when there are no more levels.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Stop when there are no more levels.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Higher levels contain older transactions, so prepend them.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Higher levels contain older transactions, so prepend them.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prepended := make([]byte, len(serialized)+len(levelData))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prepended := make([]byte, len(serialized)+len(levelData))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(prepended, levelData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(prepended, levelData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(prepended[len(levelData):], serialized)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(prepended[len(levelData):], serialized)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized = prepended</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized = prepended</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the requested number of entries to skip is larger than the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the requested number of entries to skip is larger than the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number available, skip them all and return now with the actual number</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number available, skip them all and return now with the actual number</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// skipped.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// skipped.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numEntries := uint32(len(serialized) / txEntrySize)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numEntries := uint32(len(serialized) / txEntrySize)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numToSkip &gt;= numEntries {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numToSkip &gt;= numEntries {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, numEntries, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, numEntries, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing more to do when there are no requested entries.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing more to do when there are no requested entries.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numRequested == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numRequested == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, numToSkip, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, numToSkip, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Limit the number to load based on the number of available entries,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Limit the number to load based on the number of available entries,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the number to skip, and the number requested.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the number to skip, and the number requested.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numToLoad := numEntries - numToSkip</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numToLoad := numEntries - numToSkip</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numToLoad &gt; numRequested {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if numToLoad &gt; numRequested {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numToLoad = numRequested</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numToLoad = numRequested</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start the offset after all skipped entries and load the calculated</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start the offset after all skipped entries and load the calculated</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; results := make([]database.BlockRegion, numToLoad)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; results := make([]database.BlockRegion, numToLoad)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := uint32(0); i &lt; numToLoad; i++ {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := uint32(0); i &lt; numToLoad; i++ {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Calculate the read offset according to the reverse flag.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Calculate the read offset according to the reverse flag.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var offset uint32</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var offset uint32</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if reverse {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if reverse {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = (numEntries - numToSkip - i - 1) * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = (numEntries - numToSkip - i - 1) * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = (numToSkip + i) * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = (numToSkip + i) * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Deserialize and populate the result.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Deserialize and populate the result.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := deserializeAddrIndexEntry(serialized[offset:],</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := deserializeAddrIndexEntry(serialized[offset:],</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;results[i], fetchBlockHash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;results[i], fetchBlockHash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure any deserialization errors are returned as</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ensure any deserialization errors are returned as</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// database corruption errors.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// database corruption errors.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isDeserializeErr(err) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isDeserializeErr(err) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err = database.Error{</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err = database.Error{</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ErrorCode: database.ErrCorruption,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ErrorCode: database.ErrCorruption,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Description: fmt.Sprintf(&quot;failed to &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Description: fmt.Sprintf(&quot;failed to &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;deserialized address index &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;deserialized address index &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;for key %x: %v&quot;, addrKey, err),</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;for key %x: %v&quot;, addrKey, err),</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, 0, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, 0, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return results, numToSkip, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return results, numToSkip, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// minEntriesToReachLevel returns the minimum number of entries that are</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// minEntriesToReachLevel returns the minimum number of entries that are</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// required to reach the given address index level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// required to reach the given address index level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func minEntriesToReachLevel(level uint8) int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func minEntriesToReachLevel(level uint8) int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; maxEntriesForLevel := level0MaxEntries</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; maxEntriesForLevel := level0MaxEntries</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; minRequired := 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; minRequired := 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for l := uint8(1); l &lt;= level; l++ {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for l := uint8(1); l &lt;= level; l++ {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minRequired += maxEntriesForLevel</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minRequired += maxEntriesForLevel</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxEntriesForLevel *= 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxEntriesForLevel *= 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return minRequired</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return minRequired</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// maxEntriesForLevel returns the maximum number of entries allowed for the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// maxEntriesForLevel returns the maximum number of entries allowed for the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// given address index level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// given address index level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func maxEntriesForLevel(level uint8) int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func maxEntriesForLevel(level uint8) int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numEntries := level0MaxEntries</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numEntries := level0MaxEntries</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for l := level; l &gt; 0; l-- {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for l := level; l &gt; 0; l-- {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries *= 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries *= 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return numEntries</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return numEntries</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// dbRemoveAddrIndexEntries removes the specified number of entries from from</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// dbRemoveAddrIndexEntries removes the specified number of entries from from</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// the address index for the provided key.&nbsp; An assertion error will be returned</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// the address index for the provided key.&nbsp; An assertion error will be returned</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// if the count exceeds the total number of entries in the index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// if the count exceeds the total number of entries in the index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func dbRemoveAddrIndexEntries(bucket internalBucket, addrKey [addrKeySize]byte, count int) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func dbRemoveAddrIndexEntries(bucket internalBucket, addrKey [addrKeySize]byte, count int) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to do if no entries are being deleted.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to do if no entries are being deleted.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if count &lt;= 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if count &lt;= 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Make use of a local map to track pending updates and define a closure</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Make use of a local map to track pending updates and define a closure</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to apply it to the database.&nbsp; This is done in order to reduce the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to apply it to the database.&nbsp; This is done in order to reduce the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number of database reads and because there is more than one exit</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// number of database reads and because there is more than one exit</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// path that needs to apply the updates.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// path that needs to apply the updates.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates := make(map[uint8][]byte)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates := make(map[uint8][]byte)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; applyPending := func() error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; applyPending := func() error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for level, data := range pendingUpdates {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for level, data := range pendingUpdates {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(data) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(data) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Delete(curLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Delete(curLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(curLevelKey[:], data)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := bucket.Put(curLevelKey[:], data)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Loop forwards through the levels while removing entries until the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Loop forwards through the levels while removing entries until the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// specified number has been removed.&nbsp; This will potentially result in</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// specified number has been removed.&nbsp; This will potentially result in</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entirely empty lower levels which will be backfilled below.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entirely empty lower levels which will be backfilled below.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var highestLoadedLevel uint8</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var highestLoadedLevel uint8</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numRemaining := count</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; numRemaining := count</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for level := uint8(0); numRemaining &gt; 0; level++ {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for level := uint8(0); numRemaining &gt; 0; level++ {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Load the data for the level from the database.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Load the data for the level from the database.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData := bucket.Get(curLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData := bucket.Get(curLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == 0 &amp;&amp; numRemaining &gt; 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == 0 &amp;&amp; numRemaining &gt; 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return AssertError(fmt.Sprintf(&quot;dbRemoveAddrIndexEntries &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return AssertError(fmt.Sprintf(&quot;dbRemoveAddrIndexEntries &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;not enough entries for address key %x to &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;not enough entries for address key %x to &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;delete %d entries&quot;, addrKey, count))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;delete %d entries&quot;, addrKey, count))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; highestLoadedLevel = level</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; highestLoadedLevel = level</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Delete the entire level as needed.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Delete the entire level as needed.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries := len(curLevelData) / txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries := len(curLevelData) / txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numRemaining &gt;= numEntries {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numRemaining &gt;= numEntries {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numRemaining -= numEntries</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numRemaining -= numEntries</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove remaining entries to delete from the level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove remaining entries to delete from the level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetEnd := len(curLevelData) - (numRemaining * txEntrySize)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetEnd := len(curLevelData) - (numRemaining * txEntrySize)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData[:offsetEnd]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData[:offsetEnd]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When all elements in level 0 were not removed there is nothing left</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When all elements in level 0 were not removed there is nothing left</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to do other than updating the database.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// to do other than updating the database.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(pendingUpdates[0]) != 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(pendingUpdates[0]) != 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return applyPending()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return applyPending()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point there are one or more empty levels before the current</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point there are one or more empty levels before the current</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level which need to be backfilled and the current level might have</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level which need to be backfilled and the current level might have</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// had some entries deleted from it as well.&nbsp; Since all levels after</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// had some entries deleted from it as well.&nbsp; Since all levels after</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level 0 are required to either be empty, half full, or completely</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level 0 are required to either be empty, half full, or completely</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// full, the current level must be adjusted accordingly by backfilling</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// full, the current level must be adjusted accordingly by backfilling</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// each previous levels in a way which satisfies the requirements.&nbsp; Any</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// each previous levels in a way which satisfies the requirements.&nbsp; Any</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entries that are left are assigned to level 0 after the loop as they</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entries that are left are assigned to level 0 after the loop as they</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are guaranteed to fit by the logic in the loop.&nbsp; In other words, this</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are guaranteed to fit by the logic in the loop.&nbsp; In other words, this</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// effectively squashes all remaining entries in the current level into</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// effectively squashes all remaining entries in the current level into</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the lowest possible levels while following the level rules.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the lowest possible levels while following the level rules.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Note that the level after the current level might also have entries</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Note that the level after the current level might also have entries</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// and gaps are not allowed, so this also keeps track of the lowest</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// and gaps are not allowed, so this also keeps track of the lowest</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// empty level so the code below knows how far to backfill in case it is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// empty level so the code below knows how far to backfill in case it is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// required.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// required.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel := uint8(255)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel := uint8(255)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevelData := pendingUpdates[highestLoadedLevel]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevelData := pendingUpdates[highestLoadedLevel]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries := maxEntriesForLevel(highestLoadedLevel)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries := maxEntriesForLevel(highestLoadedLevel)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for level := highestLoadedLevel; level &gt; 0; level-- {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for level := highestLoadedLevel; level &gt; 0; level-- {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there are not enough entries left in the current level</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there are not enough entries left in the current level</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// for the number that would be required to reach it, clear the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// for the number that would be required to reach it, clear the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the current level which effectively moves them all up to the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the current level which effectively moves them all up to the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// previous level on the next iteration.&nbsp; Otherwise, there are</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// previous level on the next iteration.&nbsp; Otherwise, there are</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are sufficient entries, so update the current level to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are sufficient entries, so update the current level to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// contain as many entries as possible while still leaving</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// contain as many entries as possible while still leaving</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// enough remaining entries required to reach the level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// enough remaining entries required to reach the level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries := len(curLevelData) / txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numEntries := len(curLevelData) / txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelMaxEntries := curLevelMaxEntries / 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prevLevelMaxEntries := curLevelMaxEntries / 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minPrevRequired := minEntriesToReachLevel(level - 1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minPrevRequired := minEntriesToReachLevel(level - 1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numEntries &lt; prevLevelMaxEntries+minPrevRequired {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numEntries &lt; prevLevelMaxEntries+minPrevRequired {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = level</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = level</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This level can only be completely full or half full,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This level can only be completely full or half full,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// so choose the appropriate offset to ensure enough</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// so choose the appropriate offset to ensure enough</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entries remain to reach the level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// entries remain to reach the level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var offset int</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var offset int</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numEntries-curLevelMaxEntries &gt;= minPrevRequired {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numEntries-curLevelMaxEntries &gt;= minPrevRequired {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = curLevelMaxEntries * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = curLevelMaxEntries * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; } else {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = prevLevelMaxEntries * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset = prevLevelMaxEntries * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData[:offset]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = curLevelData[:offset]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData = curLevelData[offset:]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelData = curLevelData[offset:]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries = prevLevelMaxEntries</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries = prevLevelMaxEntries</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[0] = curLevelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[0] = curLevelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(curLevelData) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = 0</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = 0</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the highest loaded level is empty, it's possible the level after</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the highest loaded level is empty, it's possible the level after</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// it still has data and thus that data needs to be backfilled as well.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// it still has data and thus that data needs to be backfilled as well.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for len(pendingUpdates[highestLoadedLevel]) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for len(pendingUpdates[highestLoadedLevel]) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the next level is empty too, the is no data left to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When the next level is empty too, the is no data left to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// continue backfilling, so there is nothing left to do.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// continue backfilling, so there is nothing left to do.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Otherwise, populate the pending updates map with the newly</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Otherwise, populate the pending updates map with the newly</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// loaded data and update the highest loaded level accordingly.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// loaded data and update the highest loaded level accordingly.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level := highestLoadedLevel + 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level := highestLoadedLevel + 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelKey := keyForLevel(addrKey, level)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData := bucket.Get(curLevelKey[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData := bucket.Get(curLevelKey[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(levelData) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(levelData) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; break</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = levelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = levelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; highestLoadedLevel = level</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; highestLoadedLevel = level</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point the highest level is not empty, but it might</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// At this point the highest level is not empty, but it might</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// be half full.&nbsp; When that is the case, move it up a level to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// be half full.&nbsp; When that is the case, move it up a level to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// simplify the code below which backfills all lower levels that</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// simplify the code below which backfills all lower levels that</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are still empty.&nbsp; This also means the current level will be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// are still empty.&nbsp; This also means the current level will be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// empty, so the loop will perform another another iteration to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// empty, so the loop will perform another another iteration to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// potentially backfill this level with data from the next one.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// potentially backfill this level with data from the next one.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries := maxEntriesForLevel(level)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries := maxEntriesForLevel(level)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(levelData)/txEntrySize != curLevelMaxEntries {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(levelData)/txEntrySize != curLevelMaxEntries {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level-1] = levelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level-1] = levelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level--</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level--</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries /= 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries /= 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Backfill all lower levels that are still empty by iteratively</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Backfill all lower levels that are still empty by iteratively</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// halfing the data until the lowest empty level is filled.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// halfing the data until the lowest empty level is filled.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for level &gt; lowestEmptyLevel {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for level &gt; lowestEmptyLevel {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset := (curLevelMaxEntries / 2) * txEntrySize</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset := (curLevelMaxEntries / 2) * txEntrySize</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = levelData[:offset]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level] = levelData[:offset]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData = levelData[offset:]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelData = levelData[offset:]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level-1] = levelData</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingUpdates[level-1] = levelData</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level--</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level--</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries /= 2</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curLevelMaxEntries /= 2</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The lowest possible empty level is now the highest loaded</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The lowest possible empty level is now the highest loaded</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// level.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = highestLoadedLevel</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lowestEmptyLevel = highestLoadedLevel</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Apply the pending updates.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Apply the pending updates.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return applyPending()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return applyPending()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// addrToKey converts known address types to an addrindex key.&nbsp; An error is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// addrToKey converts known address types to an addrindex key.&nbsp; An error is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// returned for unsupported types.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// returned for unsupported types.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func addrToKey(addr <span class="TextSegElementBranding">dcr</span>util.Address, params *chaincfg.Params) ([addrKeySize]byte, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func addrToKey(addr <span class="TextSegElementBranding">dcr</span>util.Address, params *chaincfg.Params) ([addrKeySize]byte, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch addr := addr.(type) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; switch addr := addr.(type) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressPubKeyHash:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressPubKeyHash:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch addr.DSA(params) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch addr.DSA(params) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeSecp256k1:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeSecp256k1:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeEdwards:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeEdwards:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashEdwards</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashEdwards</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeSecSchnorr:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case chainec.ECTypeSecSchnorr:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashSchnorr</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashSchnorr</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">-+</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">case</span> <span class="TextSegSigDiff">bliss.BSTypeBliss:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">var</span> <span class="TextSegSigDiff">result</span> <span class="TextSegSigDiff">[addrKeySize]byte</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">result[0]</span> <span class="TextSegSigDiff">=</span> <span class="TextSegSigDiff">addrKeyTypePubKeyHashBliss</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">copy(result[1:],</span> <span class="TextSegSigDiff">addr.Hash160()[:])</span></td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">return</span> <span class="TextSegSigDiff">result,</span> <span class="TextSegSigDiff">nil</span></td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">=</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressScriptHash:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressScriptHash:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypeScriptHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypeScriptHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressSecpPubKey:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressSecpPubKey:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressEdwardsPubKey:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressEdwardsPubKey:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashEdwards</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashEdwards</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressSecSchnorrPubKey:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; case *<span class="TextSegElementBranding">dcr</span>util.AddressSecSchnorrPubKey:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var result [addrKeySize]byte</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashSchnorr</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result[0] = addrKeyTypePubKeyHashSchnorr</td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">-+</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">copy(result[1:],</span> <span class="TextSegSigDiff">addr.AddressPubKeyHash().Hash160()[:])</span></td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">return</span> <span class="TextSegSigDiff">result,</span> <span class="TextSegSigDiff">nil</span></td>
</tr>
<tr class="SectionAll">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">=</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">-+</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">case</span> <span class="TextSegSigDiff">*</span>dcr<span class="TextSegSigDiff">util.AddressBlissPubKey:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">var</span> <span class="TextSegSigDiff">result</span> <span class="TextSegSigDiff">[addrKeySize]byte</span></td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSigMod">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegSigDiff">result[0]</span> <span class="TextSegSigDiff">=</span> <span class="TextSegSigDiff">addrKeyTypePubKeyHashBliss</span></td>
</tr>
<tr class="SectionBegin">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
<td class="AlignCenter">=</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy(result[1:], addr.AddressPubKeyHash().Hash160()[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return result, nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return [addrKeySize]byte{}, errUnsupportedAddressType</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return [addrKeySize]byte{}, errUnsupportedAddressType</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// AddrIndex implements a transaction by address index.&nbsp; That is to say, it</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// AddrIndex implements a transaction by address index.&nbsp; That is to say, it</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// supports querying all transactions that reference a given address because</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// supports querying all transactions that reference a given address because</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// they are either crediting or debiting the address.&nbsp; The returned transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// they are either crediting or debiting the address.&nbsp; The returned transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// are ordered according to their order of appearance in the blockchain.&nbsp; In</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// are ordered according to their order of appearance in the blockchain.&nbsp; In</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// other words, first by block height and then by offset inside the block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// other words, first by block height and then by offset inside the block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// In addition, support is provided for a memory-only index of unconfirmed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// In addition, support is provided for a memory-only index of unconfirmed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transactions such as those which are kept in the memory pool before inclusion</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transactions such as those which are kept in the memory pool before inclusion</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// in a block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// in a block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">type AddrIndex struct {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">type AddrIndex struct {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The following fields are set when the instance is created and can't</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The following fields are set when the instance is created and can't</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// be changed afterwards, so there is no need to protect them with a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// be changed afterwards, so there is no need to protect them with a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// separate mutex.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// separate mutex.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database.DB</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database.DB</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; chainParams *chaincfg.Params</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; chainParams *chaincfg.Params</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The following fields are used to quickly link transactions and</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The following fields are used to quickly link transactions and</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addresses that have not been included into a block yet when an</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// addresses that have not been included into a block yet when an</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address index is being maintained.&nbsp; The are protected by the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address index is being maintained.&nbsp; The are protected by the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// unconfirmedLock field.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// unconfirmedLock field.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The txnsByAddr field is used to keep an index of all transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The txnsByAddr field is used to keep an index of all transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which either create an output to a given address or spend from a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// which either create an output to a given address or spend from a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// previous output to it keyed by the address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// previous output to it keyed by the address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The addrsByTx field is essentially the reverse and is used to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The addrsByTx field is essentially the reverse and is used to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// keep an index of all addresses which a given transaction involves.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// keep an index of all addresses which a given transaction involves.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This allows fairly efficient updates when transactions are removed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// This allows fairly efficient updates when transactions are removed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// once they are included into a block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// once they are included into a block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; unconfirmedLock sync.RWMutex</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; unconfirmedLock sync.RWMutex</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; txnsByAddr&nbsp; &nbsp; &nbsp; map[[addrKeySize]byte]map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; txnsByAddr&nbsp; &nbsp; &nbsp; map[[addrKeySize]byte]map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsByTx&nbsp; &nbsp; &nbsp;&nbsp; map[chainhash.Hash]map[[addrKeySize]byte]struct{}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsByTx&nbsp; &nbsp; &nbsp;&nbsp; map[chainhash.Hash]map[[addrKeySize]byte]struct{}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Ensure the AddrIndex type implements the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Ensure the AddrIndex type implements the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">var _ Indexer = (*AddrIndex)(nil)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">var _ Indexer = (*AddrIndex)(nil)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Ensure the AddrIndex type implements the NeedsInputser interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Ensure the AddrIndex type implements the NeedsInputser interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">var _ NeedsInputser = (*AddrIndex)(nil)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">var _ NeedsInputser = (*AddrIndex)(nil)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NeedsInputs signals that the index requires the referenced inputs in order</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NeedsInputs signals that the index requires the referenced inputs in order</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// to properly create the index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// to properly create the index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This implements the NeedsInputser interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This implements the NeedsInputser interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) NeedsInputs() bool {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) NeedsInputs() bool {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return true</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return true</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Init is only provided to satisfy the Indexer interface as there is nothing to</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Init is only provided to satisfy the Indexer interface as there is nothing to</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// initialize for this index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// initialize for this index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) Init() error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) Init() error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to do.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to do.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Key returns the database key to use for the index as a byte slice.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Key returns the database key to use for the index as a byte slice.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) Key() []byte {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) Key() []byte {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return addrIndexKey</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return addrIndexKey</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Name returns the human-readable name of the index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Name returns the human-readable name of the index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) Name() string {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) Name() string {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return addrIndexName</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return addrIndexName</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Create is invoked when the indexer manager determines the index needs</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Create is invoked when the indexer manager determines the index needs</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// to be created for the first time.&nbsp; It creates the bucket for the address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// to be created for the first time.&nbsp; It creates the bucket for the address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) Create(dbTx database.Tx) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) Create(dbTx database.Tx) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; _, err := dbTx.Metadata().CreateBucket(addrIndexKey)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; _, err := dbTx.Metadata().CreateBucket(addrIndexKey)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// writeIndexData represents the address index data to be written for one block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// writeIndexData represents the address index data to be written for one block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// It consistens of the address mapped to an ordered list of the transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// It consistens of the address mapped to an ordered list of the transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// that involve the address in block.&nbsp; It is ordered so the transactions can be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// that involve the address in block.&nbsp; It is ordered so the transactions can be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// stored in the order they appear in the block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// stored in the order they appear in the block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">type writeIndexData map[[addrKeySize]byte][]int</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">type writeIndexData map[[addrKeySize]byte][]int</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// indexPkScript extracts all standard addresses from the passed public key</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// indexPkScript extracts all standard addresses from the passed public key</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// script and maps each of them to the associated transaction using the passed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// script and maps each of them to the associated transaction using the passed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// map.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// map.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) indexPkScript(data writeIndexData, scriptVersion uint16, pkScript []byte, txIdx int, isSStx bool) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) indexPkScript(data writeIndexData, scriptVersion uint16, pkScript []byte, txIdx int, isSStx bool) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to index if the script is non-standard or otherwise doesn't</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to index if the script is non-standard or otherwise doesn't</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// contain any addresses.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// contain any addresses.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; class, addrs, _, err := txscript.ExtractPkScriptAddrs(scriptVersion, pkScript,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; class, addrs, _, err := txscript.ExtractPkScriptAddrs(scriptVersion, pkScript,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if isSStx &amp;&amp; class == txscript.NullDataTy {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if isSStx &amp;&amp; class == txscript.NullDataTy {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr, err := stake.AddrFromSStxPkScrCommitment(pkScript, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr, err := stake.AddrFromSStxPkScrCommitment(pkScript, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrs = append(addrs, addr)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrs = append(addrs, addr)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(addrs) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(addrs) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, addr := range addrs {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, addr := range addrs {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Avoid inserting the transaction more than once.&nbsp; Since the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Avoid inserting the transaction more than once.&nbsp; Since the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transactions are indexed serially any duplicates will be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transactions are indexed serially any duplicates will be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// indexed in a row, so checking the most recent entry for the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// indexed in a row, so checking the most recent entry for the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address is enough to detect duplicates.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// address is enough to detect duplicates.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexedTxns := data[addrKey]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexedTxns := data[addrKey]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numTxns := len(indexedTxns)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numTxns := len(indexedTxns)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numTxns &gt; 0 &amp;&amp; indexedTxns[numTxns-1] == txIdx {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if numTxns &gt; 0 &amp;&amp; indexedTxns[numTxns-1] == txIdx {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexedTxns = append(indexedTxns, txIdx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexedTxns = append(indexedTxns, txIdx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data[addrKey] = indexedTxns</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data[addrKey] = indexedTxns</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// indexBlock extract all of the standard addresses from all of the transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// indexBlock extract all of the standard addresses from all of the transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// in the parent of the passed block (if they were valid) and all of the stake</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// in the parent of the passed block (if they were valid) and all of the stake</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transactions in the passed block, and maps each of them to the associated</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transactions in the passed block, and maps each of them to the associated</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transaction using the passed map.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transaction using the passed map.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) indexBlock(data writeIndexData, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) indexBlock(data writeIndexData, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentRegularTxs []*<span class="TextSegElementBranding">dcr</span>util.Tx</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentRegularTxs []*<span class="TextSegElementBranding">dcr</span>util.Tx</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if approvesParent(block) &amp;&amp; block.Height() &gt; 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if approvesParent(block) &amp;&amp; block.Height() &gt; 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentRegularTxs = parent.Transactions()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentRegularTxs = parent.Transactions()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for txIdx, tx := range parentRegularTxs {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for txIdx, tx := range parentRegularTxs {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Coinbases do not reference any inputs.&nbsp; Since the block is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Coinbases do not reference any inputs.&nbsp; Since the block is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// required to have already gone through full validation, it has</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// required to have already gone through full validation, it has</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// already been proven on the first transaction in the block is</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// already been proven on the first transaction in the block is</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// a coinbase.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// a coinbase.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if txIdx != 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if txIdx != 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txIn := range tx.MsgTx().TxIn {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txIn := range tx.MsgTx().TxIn {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The view should always have the input since</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The view should always have the input since</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the index contract requires it, however, be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the index contract requires it, however, be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe and simply ignore any missing entries.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe and simply ignore any missing entries.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origin := &amp;txIn.PreviousOutPoint</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origin := &amp;txIn.PreviousOutPoint</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := view.LookupEntry(&amp;origin.Hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := view.LookupEntry(&amp;origin.Hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; log.Warnf(&quot;Missing input %v for tx %v while &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; log.Warnf(&quot;Missing input %v for tx %v while &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;indexing block %v (height %v)\n&quot;, origin.Hash,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;indexing block %v (height %v)\n&quot;, origin.Hash,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tx.Hash(), block.Hash(), block.Height())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tx.Hash(), block.Hash(), block.Height())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(origin.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(origin.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(origin.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(origin.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, version, pkScript, txIdx,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, version, pkScript, txIdx,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range tx.MsgTx().TxOut {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range tx.MsgTx().TxOut {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, txOut.Version, txOut.PkScript, txIdx,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, txOut.Version, txOut.PkScript, txIdx,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; false)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; false)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for txIdx, tx := range block.STransactions() {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for txIdx, tx := range block.STransactions() {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thisTxOffset := txIdx + len(parentRegularTxs)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thisTxOffset := txIdx + len(parentRegularTxs)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSSGen, _ := stake.IsSSGen(msgTx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSSGen, _ := stake.IsSSGen(msgTx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for i, txIn := range msgTx.TxIn {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for i, txIn := range msgTx.TxIn {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Skip stakebases.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Skip stakebases.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isSSGen &amp;&amp; i == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if isSSGen &amp;&amp; i == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The view should always have the input since</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The view should always have the input since</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the index contract requires it, however, be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the index contract requires it, however, be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe and simply ignore any missing entries.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe and simply ignore any missing entries.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origin := &amp;txIn.PreviousOutPoint</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origin := &amp;txIn.PreviousOutPoint</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := view.LookupEntry(&amp;origin.Hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := view.LookupEntry(&amp;origin.Hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; log.Warnf(&quot;Missing input %v for tx %v while &quot;+</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; log.Warnf(&quot;Missing input %v for tx %v while &quot;+</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;indexing block %v (height %v)\n&quot;, origin.Hash,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;indexing block %v (height %v)\n&quot;, origin.Hash,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tx.Hash(), block.Hash(), block.Height())</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tx.Hash(), block.Hash(), block.Height())</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(origin.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(origin.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(origin.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(origin.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, version, pkScript, thisTxOffset,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, version, pkScript, thisTxOffset,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSStx, _ := stake.IsSStx(msgTx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSStx, _ := stake.IsSStx(msgTx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range msgTx.TxOut {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range msgTx.TxOut {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, txOut.Version, txOut.PkScript,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexPkScript(data, txOut.Version, txOut.PkScript,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thisTxOffset, isSStx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; thisTxOffset, isSStx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// ConnectBlock is invoked by the index manager when a new block has been</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// ConnectBlock is invoked by the index manager when a new block has been</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// connected to the main chain.&nbsp; This indexer adds a mapping for each address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// connected to the main chain.&nbsp; This indexer adds a mapping for each address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// the transactions in the block involve.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// the transactions in the block involve.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) ConnectBlock(dbTx database.Tx, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) ConnectBlock(dbTx database.Tx, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The offset and length of the transactions within the serialized</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The offset and length of the transactions within the serialized</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// block for the regular transactions of the previous block, if</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// block for the regular transactions of the previous block, if</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// applicable.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// applicable.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentTxLocs []wire.TxLoc</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentTxLocs []wire.TxLoc</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentBlockID uint32</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var parentBlockID uint32</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if approvesParent(block) &amp;&amp; block.Height() &gt; 1 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if approvesParent(block) &amp;&amp; block.Height() &gt; 1 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var err error</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var err error</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentTxLocs, _, err = parent.TxLoc()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentTxLocs, _, err = parent.TxLoc()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentHash := parent.Hash()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentHash := parent.Hash()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentBlockID, err = dbFetchBlockIDByHash(dbTx, parentHash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentBlockID, err = dbFetchBlockIDByHash(dbTx, parentHash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The offset and length of the transactions within the serialized</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The offset and length of the transactions within the serialized</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// block for the added stake transactions.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// block for the added stake transactions.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; _, blockStxLocs, err := block.TxLoc()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; _, blockStxLocs, err := block.TxLoc()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to index, just return.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Nothing to index, just return.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(parentTxLocs)+len(blockStxLocs) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(parentTxLocs)+len(blockStxLocs) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Get the internal block ID associated with the block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Get the internal block ID associated with the block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; blockHash := block.Hash()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; blockHash := block.Hash()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; blockID, err := dbFetchBlockIDByHash(dbTx, blockHash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; blockID, err := dbFetchBlockIDByHash(dbTx, blockHash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Build all of the address to transaction mappings in a local map.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Build all of the address to transaction mappings in a local map.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsToTxns := make(writeIndexData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsToTxns := make(writeIndexData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.indexBlock(addrsToTxns, block, parent, view)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.indexBlock(addrsToTxns, block, parent, view)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add all of the index entries for each address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add all of the index entries for each address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; stakeIdxsStart := len(parentTxLocs)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; stakeIdxsStart := len(parentTxLocs)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; allTxLocs := append(parentTxLocs, blockStxLocs...)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; allTxLocs := append(parentTxLocs, blockStxLocs...)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIdxBucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrIdxBucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey, txIdxs := range addrsToTxns {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey, txIdxs := range addrsToTxns {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txIdx := range txIdxs {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, txIdx := range txIdxs {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Switch to using the newest block ID for the stake transactions,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Switch to using the newest block ID for the stake transactions,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// since these are not from the parent. Offset the index to be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// since these are not from the parent. Offset the index to be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// correct for the location in this given block.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// correct for the location in this given block.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse := parentBlockID</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse := parentBlockID</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if txIdx &gt;= stakeIdxsStart {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if txIdx &gt;= stakeIdxsStart {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse = blockID</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse = blockID</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := dbPutAddrIndexEntry(addrIdxBucket, addrKey,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := dbPutAddrIndexEntry(addrIdxBucket, addrKey,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse, allTxLocs[txIdx])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockIDToUse, allTxLocs[txIdx])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// DisconnectBlock is invoked by the index manager when a block has been</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// DisconnectBlock is invoked by the index manager when a block has been</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// disconnected from the main chain.&nbsp; This indexer removes the address mappings</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// disconnected from the main chain.&nbsp; This indexer removes the address mappings</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// each transaction in the block involve.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// each transaction in the block involve.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This is part of the Indexer interface.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) DisconnectBlock(dbTx database.Tx, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) DisconnectBlock(dbTx database.Tx, block, parent *<span class="TextSegElementBranding">dcr</span>util.Block, view *blockchain.UtxoViewpoint) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Build all of the address to transaction mappings in a local map.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Build all of the address to transaction mappings in a local map.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsToTxns := make(writeIndexData)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrsToTxns := make(writeIndexData)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.indexBlock(addrsToTxns, block, parent, view)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.indexBlock(addrsToTxns, block, parent, view)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove all of the index entries for each address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove all of the index entries for each address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; bucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey, txIdxs := range addrsToTxns {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey, txIdxs := range addrsToTxns {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := dbRemoveAddrIndexEntries(bucket, addrKey, len(txIdxs))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; err := dbRemoveAddrIndexEntries(bucket, addrKey, len(txIdxs))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// TxRegionsForAddress returns a slice of block regions which identify each</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// TxRegionsForAddress returns a slice of block regions which identify each</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// transaction that involves the passed address according to the specified</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// transaction that involves the passed address according to the specified</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// number to skip, number requested, and whether or not the results should be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// number to skip, number requested, and whether or not the results should be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// reversed.&nbsp; It also returns the number actually skipped since it could be less</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// reversed.&nbsp; It also returns the number actually skipped since it could be less</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// in the case where there are not enough entries.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// in the case where there are not enough entries.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NOTE: These results only include transactions confirmed in blocks.&nbsp; See the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NOTE: These results only include transactions confirmed in blocks.&nbsp; See the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// UnconfirmedTxnsForAddress method for obtaining unconfirmed transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// UnconfirmedTxnsForAddress method for obtaining unconfirmed transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// that involve a given address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// that involve a given address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) TxRegionsForAddress(dbTx database.Tx, addr <span class="TextSegElementBranding">dcr</span>util.Address, numToSkip, numRequested uint32, reverse bool) ([]database.BlockRegion, uint32, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) TxRegionsForAddress(dbTx database.Tx, addr <span class="TextSegElementBranding">dcr</span>util.Address, numToSkip, numRequested uint32, reverse bool) ([]database.BlockRegion, uint32, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, 0, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil, 0, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var regions []database.BlockRegion</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var regions []database.BlockRegion</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var skipped uint32</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var skipped uint32</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; err = idx.db.View(func(dbTx database.Tx) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; err = idx.db.View(func(dbTx database.Tx) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Create closure to lookup the block hash given the ID using</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Create closure to lookup the block hash given the ID using</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the database transaction.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// the database transaction.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fetchBlockHash := func(id []byte) (*chainhash.Hash, error) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fetchBlockHash := func(id []byte) (*chainhash.Hash, error) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Deserialize and populate the result.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Deserialize and populate the result.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return dbFetchBlockHashBySerializedID(dbTx, id)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return dbFetchBlockHashBySerializedID(dbTx, id)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var err error</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var err error</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIdxBucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIdxBucket := dbTx.Metadata().Bucket(addrIndexKey)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regions, skipped, err = dbFetchAddrIndexEntries(addrIdxBucket,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regions, skipped, err = dbFetchAddrIndexEntries(addrIdxBucket,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, numToSkip, numRequested, reverse,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, numToSkip, numRequested, reverse,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fetchBlockHash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fetchBlockHash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; })</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; })</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return regions, skipped, err</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return regions, skipped, err</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// indexUnconfirmedAddresses modifies the unconfirmed (memory-only) address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// indexUnconfirmedAddresses modifies the unconfirmed (memory-only) address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// index to include mappings for the addresses encoded by the passed public key</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// index to include mappings for the addresses encoded by the passed public key</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// script to the transaction.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// script to the transaction.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) indexUnconfirmedAddresses(scriptVersion uint16, pkScript []byte, tx *<span class="TextSegElementBranding">dcr</span>util.Tx, isSStx bool) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) indexUnconfirmedAddresses(scriptVersion uint16, pkScript []byte, tx *<span class="TextSegElementBranding">dcr</span>util.Tx, isSStx bool) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The error is ignored here since the only reason it can fail is if the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The error is ignored here since the only reason it can fail is if the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// script fails to parse and it was already validated before being</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// script fails to parse and it was already validated before being</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// admitted to the mempool.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// admitted to the mempool.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; class, addresses, _, _ := txscript.ExtractPkScriptAddrs(scriptVersion,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; class, addresses, _, _ := txscript.ExtractPkScriptAddrs(scriptVersion,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if isSStx &amp;&amp; class == txscript.NullDataTy {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if isSStx &amp;&amp; class == txscript.NullDataTy {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr, err := stake.AddrFromSStxPkScrCommitment(pkScript, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addr, err := stake.AddrFromSStxPkScrCommitment(pkScript, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Fail if this fails to decode. It should.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Fail if this fails to decode. It should.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addresses = append(addresses, addr)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addresses = append(addresses, addr)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, addr := range addresses {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, addr := range addresses {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add a mapping from the address to the transaction.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add a mapping from the address to the transaction.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Lock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Lock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry := idx.txnsByAddr[addrKey]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry := idx.txnsByAddr[addrKey]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if addrIndexEntry == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if addrIndexEntry == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry = make(map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry = make(map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.txnsByAddr[addrKey] = addrIndexEntry</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.txnsByAddr[addrKey] = addrIndexEntry</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry[*tx.Hash()] = tx</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrIndexEntry[*tx.Hash()] = tx</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add a mapping from the transaction to the address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Add a mapping from the transaction to the address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry := idx.addrsByTx[*tx.Hash()]</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry := idx.addrsByTx[*tx.Hash()]</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if addrsByTxEntry == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if addrsByTxEntry == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry = make(map[[addrKeySize]byte]struct{})</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry = make(map[[addrKeySize]byte]struct{})</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.addrsByTx[*tx.Hash()] = addrsByTxEntry</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.addrsByTx[*tx.Hash()] = addrsByTxEntry</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry[addrKey] = struct{}{}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTxEntry[addrKey] = struct{}{}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Unlock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Unlock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// AddUnconfirmedTx adds all addresses related to the transaction to the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// AddUnconfirmedTx adds all addresses related to the transaction to the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// unconfirmed (memory-only) address index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// unconfirmed (memory-only) address index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NOTE: This transaction MUST have already been validated by the memory pool</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NOTE: This transaction MUST have already been validated by the memory pool</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// before calling this function with it and have all of the inputs available in</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// before calling this function with it and have all of the inputs available in</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// the provided utxo view.&nbsp; Failure to do so could result in some or all</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// the provided utxo view.&nbsp; Failure to do so could result in some or all</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// addresses not being indexed.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// addresses not being indexed.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) AddUnconfirmedTx(tx *<span class="TextSegElementBranding">dcr</span>util.Tx, utxoView *blockchain.UtxoViewpoint) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) AddUnconfirmedTx(tx *<span class="TextSegElementBranding">dcr</span>util.Tx, utxoView *blockchain.UtxoViewpoint) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Index addresses of all referenced previous transaction outputs.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Index addresses of all referenced previous transaction outputs.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The existence checks are elided since this is only called after the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The existence checks are elided since this is only called after the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transaction has already been validated and thus all inputs are</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// transaction has already been validated and thus all inputs are</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// already known to exist.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// already known to exist.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; isSSGen, _ := stake.IsSSGen(msgTx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; isSSGen, _ := stake.IsSSGen(msgTx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i, txIn := range msgTx.TxIn {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i, txIn := range msgTx.TxIn {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Skip stakebase.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Skip stakebase.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if i == 0 &amp;&amp; isSSGen {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if i == 0 &amp;&amp; isSSGen {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := utxoView.LookupEntry(&amp;txIn.PreviousOutPoint.Hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry := utxoView.LookupEntry(&amp;txIn.PreviousOutPoint.Hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if entry == nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore missing entries.&nbsp; This should never happen</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore missing entries.&nbsp; This should never happen</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// in practice since the function comments specifically</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// in practice since the function comments specifically</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// call out all inputs must be available.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// call out all inputs must be available.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continue</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(txIn.PreviousOutPoint.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; version := entry.ScriptVersionByIndex(txIn.PreviousOutPoint.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(txIn.PreviousOutPoint.Index)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pkScript := entry.PkScriptByIndex(txIn.PreviousOutPoint.Index)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType := entry.TransactionType()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexUnconfirmedAddresses(version, pkScript, tx,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexUnconfirmedAddresses(version, pkScript, tx,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txType == stake.TxTypeSStx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Index addresses of all created outputs.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Index addresses of all created outputs.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; isSStx, _ := stake.IsSStx(msgTx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; isSStx, _ := stake.IsSStx(msgTx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range msgTx.TxOut {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for _, txOut := range msgTx.TxOut {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexUnconfirmedAddresses(txOut.Version, txOut.PkScript, tx,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx.indexUnconfirmedAddresses(txOut.Version, txOut.PkScript, tx,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSStx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSStx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// RemoveUnconfirmedTx removes the passed transaction from the unconfirmed</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// RemoveUnconfirmedTx removes the passed transaction from the unconfirmed</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// (memory-only) address index.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// (memory-only) address index.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) RemoveUnconfirmedTx(hash *chainhash.Hash) {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) RemoveUnconfirmedTx(hash *chainhash.Hash) {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Lock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.Lock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; defer idx.unconfirmedLock.Unlock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; defer idx.unconfirmedLock.Unlock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove all address references to the transaction from the address</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove all address references to the transaction from the address</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index and remove the entry for the address altogether if it no longer</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// index and remove the entry for the address altogether if it no longer</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// references any transactions.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// references any transactions.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey := range idx.addrsByTx[*hash] {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for addrKey := range idx.addrsByTx[*hash] {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; delete(idx.txnsByAddr[addrKey], *hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; delete(idx.txnsByAddr[addrKey], *hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(idx.txnsByAddr[addrKey]) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; if len(idx.txnsByAddr[addrKey]) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; delete(idx.txnsByAddr, addrKey)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; delete(idx.txnsByAddr, addrKey)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove the entry from the transaction to address lookup map as well.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Remove the entry from the transaction to address lookup map as well.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; delete(idx.addrsByTx, *hash)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; delete(idx.addrsByTx, *hash)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// UnconfirmedTxnsForAddress returns all transactions currently in the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// UnconfirmedTxnsForAddress returns all transactions currently in the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// unconfirmed (memory-only) address index that involve the passed address.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// unconfirmed (memory-only) address index that involve the passed address.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Unsupported address types are ignored and will result in no results.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Unsupported address types are ignored and will result in no results.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// This function is safe for concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func (idx *AddrIndex) UnconfirmedTxnsForAddress(addr <span class="TextSegElementBranding">dcr</span>util.Address) []*<span class="TextSegElementBranding">dcr</span>util.Tx {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func (idx *AddrIndex) UnconfirmedTxnsForAddress(addr <span class="TextSegElementBranding">dcr</span>util.Address) []*<span class="TextSegElementBranding">dcr</span>util.Tx {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Ignore unsupported address types.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; addrKey, err := addrToKey(addr, idx.chainParams)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if err != nil {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Protect concurrent access.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Protect concurrent access.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.RLock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; idx.unconfirmedLock.RLock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; defer idx.unconfirmedLock.RUnlock()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; defer idx.unconfirmedLock.RUnlock()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Return a new slice with the results if there are any.&nbsp; This ensures</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Return a new slice with the results if there are any.&nbsp; This ensures</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe concurrency.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// safe concurrency.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if txns, exists := idx.txnsByAddr[addrKey]; exists {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if txns, exists := idx.txnsByAddr[addrKey]; exists {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addressTxns := make([]*<span class="TextSegElementBranding">dcr</span>util.Tx, 0, len(txns))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addressTxns := make([]*<span class="TextSegElementBranding">dcr</span>util.Tx, 0, len(txns))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, tx := range txns {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; for _, tx := range txns {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addressTxns = append(addressTxns, tx)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addressTxns = append(addressTxns, tx)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return addressTxns</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return addressTxns</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// NewAddrIndex returns a new instance of an indexer that is used to create a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// NewAddrIndex returns a new instance of an indexer that is used to create a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// mapping of all addresses in the blockchain to the respective transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// mapping of all addresses in the blockchain to the respective transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// that involve them.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// that involve them.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// It implements the Indexer interface which plugs into the IndexManager that in</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// It implements the Indexer interface which plugs into the IndexManager that in</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// turn is used by the blockchain package.&nbsp; This allows the index to be</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// turn is used by the blockchain package.&nbsp; This allows the index to be</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// seamlessly maintained along with the chain.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// seamlessly maintained along with the chain.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func NewAddrIndex(db database.DB, chainParams *chaincfg.Params) *AddrIndex {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func NewAddrIndex(db database.DB, chainParams *chaincfg.Params) *AddrIndex {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;AddrIndex{</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;AddrIndex{</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; db:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; db:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chainParams: chainParams,</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chainParams: chainParams,</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txnsByAddr:&nbsp; make(map[[addrKeySize]byte]map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx),</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txnsByAddr:&nbsp; make(map[[addrKeySize]byte]map[chainhash.Hash]*<span class="TextSegElementBranding">dcr</span>util.Tx),</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTx:&nbsp;&nbsp; make(map[chainhash.Hash]map[[addrKeySize]byte]struct{}),</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; addrsByTx:&nbsp;&nbsp; make(map[chainhash.Hash]map[[addrKeySize]byte]struct{}),</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// DropAddrIndex drops the address index from the provided database if it</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// DropAddrIndex drops the address index from the provided database if it</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// exists.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// exists.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func DropAddrIndex(db database.DB) error {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func DropAddrIndex(db database.DB) error {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return dropIndex(db, addrIndexKey, addrIndexName)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return dropIndex(db, addrIndexKey, addrIndexName)</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
</table>
<br/>
</body>
</html>
