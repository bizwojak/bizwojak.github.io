<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style>
.AlignLeft { text-align: left; }
.AlignCenter { text-align: center; }
.AlignRight { text-align: right; }
body { font-family: sans-serif; font-size: 11pt; }
img.AutoScale { max-width: 100%; max-height: 100%; }
td { vertical-align: top; padding-left: 4px; padding-right: 4px; }

tr.SectionGap td { font-size: 4px; border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionBegin td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Black; border-right: 1px solid Black; }
tr.SectionMiddle td { border-left: none; border-top: none; border-right: 1px solid Black; }
tr.SubsectionAll td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
tr.SubsectionEnd td { border-left: none; border-top: none; border-bottom: 1px solid Gray; border-right: 1px solid Black; }
table.fc { border-top: 1px solid Black; border-left: 1px solid Black; width: 100%; font-family: monospace; font-size: 10pt; }
td.TextItemInsigMod { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigOrphan { color: #000000; background-color: #FAEEFF; }
td.TextItemNum { color: #696969; background-color: #F0F0F0; }
td.TextItemSame { color: #000000; background-color: #FFFFFF; }
td.TextItemSigMod { color: #000000; background-color: #FFE3E3; }
td.TextItemSigOrphan { color: #000000; background-color: #F1E3FF; }
.TextSegInsigDiff { color: #0000FF; }
.TextSegReplacedDiff { color: #0000FF; font-style: italic; }
.TextSegSigDiff { color: #FF0000; }
td.TextItemInsigAdd { color: #000000; background-color: #EEEEFF; }
td.TextItemInsigDel { color: #000000; background-color: #EEEEFF; text-decoration: line-through; }
td.TextItemSigAdd { color: #000000; background-color: #FFE3E3; }
td.TextItemSigDel { color: #000000; background-color: #FFE3E3; text-decoration: line-through; }
.TextSegElementComment { color: #786A41; }
.TextSegElementBranding { }
</style>
<title>dcrd-1.1.0 <--> hxd-rc1.0 Comparison</title>
</head>
<body>
dcrd-1.1.0 <--> hxd-rc1.0 Comparison<br/>
Produced: 10/3/2018 11:00:10 PM<br/>
&nbsp; &nbsp;
<br/>
Mode:&nbsp; All, Ignoring Unimportant &nbsp;
<br/>
Left file: dcrd-1.1.0\blockchain\merkle.go &nbsp;
<br/>
Right file: hxd-rc1.0\blockchain\merkle.go &nbsp;
<br/>
<table class="fc" cellspacing="0" cellpadding="0">
<tr class="SectionBegin">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2013-2016 The btcsuite developers</span></td>
<td class="AlignCenter">=</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2013-2016 The btcsuite developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2015-2016 The Decred developers</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Copyright (c) 2015-2016 The Decred developers</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Use of this source code is governed by an ISC</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// license that can be found in the LICENSE file.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">package blockchain</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">package blockchain</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">import (</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">import (</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;math&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;math&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red</span>/<span class="TextSegElementBranding">dcr</span>d/chaincfg/chainhash&quot;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &quot;github.com/<span class="TextSegElementBranding">hybridnetwork</span>/<span class="TextSegElementBranding">hx</span>d/chaincfg/chainhash&quot;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementBranding">&quot;github.com/</span><span class="TextSegElementBranding">d</span><span class="TextSegElementBranding">ec</span><span class="TextSegElementBranding">red/dcr</span><span class="TextSegElementBranding">util&quot;</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementBranding">dcrutil </span><span class="TextSegElementBranding">&quot;github.com/</span><span class="TextSegElementBranding">hybridnetwork</span><span class="TextSegElementBranding">/hx</span><span class="TextSegElementBranding">util&quot;</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// nextPowerOfTwo returns the next highest power of two from a given number if</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// nextPowerOfTwo returns the next highest power of two from a given number if</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// it is not already a power of two.&nbsp; This is a helper function used during the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// it is not already a power of two.&nbsp; This is a helper function used during the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// calculation of a merkle tree.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// calculation of a merkle tree.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func nextPowerOfTwo(n int) int {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func nextPowerOfTwo(n int) int {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Return the number if it's already a power of 2.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Return the number if it's already a power of 2.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if n&amp;(n-1) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if n&amp;(n-1) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return n</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return n</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Figure out and return the next power of two.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Figure out and return the next power of two.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exponent := uint(math.Log2(float64(n))) + 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; exponent := uint(math.Log2(float64(n))) + 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return 1 &lt;&lt; exponent <span class="TextSegElementComment">// 2^exponent</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return 1 &lt;&lt; exponent <span class="TextSegElementComment">// 2^exponent</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// HashMerkleBranches takes two hashes, treated as the left and right tree</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// HashMerkleBranches takes two hashes, treated as the left and right tree</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// nodes, and returns the hash of their concatenation.&nbsp; This is a helper</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// nodes, and returns the hash of their concatenation.&nbsp; This is a helper</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// function used to aid in the generation of a merkle tree.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// function used to aid in the generation of a merkle tree.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func HashMerkleBranches(left *chainhash.Hash, right *chainhash.Hash) *chainhash.Hash {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func HashMerkleBranches(left *chainhash.Hash, right *chainhash.Hash) *chainhash.Hash {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Concatenate the left and right nodes.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Concatenate the left and right nodes.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var hash [chainhash.HashSize * 2]byte</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; var hash [chainhash.HashSize * 2]byte</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(hash[:chainhash.HashSize], left[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(hash[:chainhash.HashSize], left[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(hash[chainhash.HashSize:], right[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; copy(hash[chainhash.HashSize:], right[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; newHash := chainhash.HashH(hash[:])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; newHash := chainhash.HashH(hash[:])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;newHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return &amp;newHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// stores it using a linear array, and returns a slice of the backing array.&nbsp; A</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// stores it using a linear array, and returns a slice of the backing array.&nbsp; A</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// linear array was chosen as opposed to an actual tree structure since it uses</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// linear array was chosen as opposed to an actual tree structure since it uses</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// about half as much memory.&nbsp; The following describes a merkle tree and how it</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// about half as much memory.&nbsp; The following describes a merkle tree and how it</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// is stored in a linear array.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// is stored in a linear array.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// A merkle tree is a tree in which every non-leaf node is the hash of its</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// A merkle tree is a tree in which every non-leaf node is the hash of its</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// children nodes.&nbsp; A diagram depicting how this works for decred transactions</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// children nodes.&nbsp; A diagram depicting how this works for decred transactions</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// where h(x) is a blake256 hash follows:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// where h(x) is a blake256 hash follows:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root = h1234 = h(h12 + h34)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; root = h1234 = h(h12 + h34)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; \</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; h12 = h(h1 + h2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h34 = h(h3 + h4)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp; h12 = h(h1 + h2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h34 = h(h3 + h4)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; h1 = h(tx1)&nbsp; h2 = h(tx2)&nbsp; &nbsp; h3 = h(tx3)&nbsp; h4 = h(tx4)</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; h1 = h(tx1)&nbsp; h2 = h(tx2)&nbsp; &nbsp; h3 = h(tx3)&nbsp; h4 = h(tx4)</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The above stored as a linear array is as follows:</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The above stored as a linear array is as follows:</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; [h1 h2 h3 h4 h12 h34 root]</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//&nbsp; &nbsp; &nbsp; [h1 h2 h3 h4 h12 h34 root]</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// As the above shows, the merkle root is always the last element in the array.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// As the above shows, the merkle root is always the last element in the array.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">//</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// The number of inputs is not always a power of two which results in a</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// The number of inputs is not always a power of two which results in a</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// balanced tree structure as above.&nbsp; In that case, parent nodes with no</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// balanced tree structure as above.&nbsp; In that case, parent nodes with no</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// children are also zero and parent nodes with only a single left node</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// children are also zero and parent nodes with only a single left node</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// are calculated by concatenating the left node with itself before hashing.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// are calculated by concatenating the left node with itself before hashing.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// Since this function uses nodes that are pointers to the hashes, empty nodes</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// Since this function uses nodes that are pointers to the hashes, empty nodes</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame"><span class="TextSegElementComment">// will be nil.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame"><span class="TextSegElementComment">// will be nil.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">func BuildMerkleTreeStore(transactions []*<span class="TextSegElementBranding">dcr</span>util.Tx) []*chainhash.Hash {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">func BuildMerkleTreeStore(transactions []*<span class="TextSegElementBranding">dcr</span>util.Tx) []*chainhash.Hash {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// If there's an empty stake tree, return totally zeroed out merkle tree root</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// If there's an empty stake tree, return totally zeroed out merkle tree root</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// only.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// only.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(transactions) == 0 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if len(transactions) == 0 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles := make([]*chainhash.Hash, 1)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles := make([]*chainhash.Hash, 1)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[0] = &amp;chainhash.Hash{}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[0] = &amp;chainhash.Hash{}</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return merkles</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return merkles</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Calculate how many entries are required to hold the binary merkle</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Calculate how many entries are required to hold the binary merkle</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// tree as a linear array and create an array of that size.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// tree as a linear array and create an array of that size.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; nextPoT := nextPowerOfTwo(len(transactions))</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; nextPoT := nextPowerOfTwo(len(transactions))</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; arraySize := nextPoT*2 - 1</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; arraySize := nextPoT*2 - 1</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; merkles := make([]*chainhash.Hash, arraySize)</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; merkles := make([]*chainhash.Hash, arraySize)</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Create the base transaction hashes and populate the array with them.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Create the base transaction hashes and populate the array with them.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i, tx := range transactions {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i, tx := range transactions {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgTx := tx.MsgTx()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txHashFull := msgTx.TxHashFull()</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; txHashFull := msgTx.TxHashFull()</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[i] = &amp;txHashFull</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[i] = &amp;txHashFull</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start the array offset after the last transaction and adjusted to the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// Start the array offset after the last transaction and adjusted to the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// next power of two.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// next power of two.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; offset := nextPoT</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; offset := nextPoT</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := 0; i &lt; arraySize-1; i += 2 {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for i := 0; i &lt; arraySize-1; i += 2 {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch {</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switch {</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there is no left child node, the parent is nil too.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there is no left child node, the parent is nil too.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case merkles[i] == nil:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case merkles[i] == nil:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = nil</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = nil</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there is no right child, the parent is generated by</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// When there is no right child, the parent is generated by</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hashing the concatenation of the left child with itself.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// hashing the concatenation of the left child with itself.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case merkles[i+1] == nil:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; case merkles[i+1] == nil:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newHash := HashMerkleBranches(merkles[i], merkles[i])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newHash := HashMerkleBranches(merkles[i], merkles[i])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = newHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = newHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The normal case sets the parent node to the hash of the</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// The normal case sets the parent node to the hash of the</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// concatentation of the left and right children.</span></td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="TextSegElementComment">// concatentation of the left and right children.</span></td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; default:</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; default:</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newHash := HashMerkleBranches(merkles[i], merkles[i+1])</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newHash := HashMerkleBranches(merkles[i], merkles[i+1])</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = newHash</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; merkles[offset] = newHash</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset++</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offset++</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;</td>
</tr>
<tr class="SectionMiddle">
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return merkles</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return merkles</td>
</tr>
<tr class="SectionEnd">
<td class="TextItemSame">}</td>
<td class="AlignCenter">&nbsp;</td>
<td class="TextItemSame">}</td>
</tr>
</table>
<br/>
</body>
</html>
